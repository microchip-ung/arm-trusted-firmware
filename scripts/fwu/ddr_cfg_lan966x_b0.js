/*
 * Copyright (C) 2022 Microchip Technology Inc. and its subsidiaries.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

const ddr_cfg_lan966x = new Map([
 ["info", ["version", "speed", "mem_size_mb", "bus_width"]],
 ["main", [ "dfimisc",  "dfitmg0",  "dfitmg1",  "dfiupd0",  "dfiupd1",  "ecccfg0",  "init0",  "init1",  "init3",  "init4",  "init5",  "mstr",  "pccfg",  "pwrctl",  "rfshctl0",  "rfshctl3",  ] ],
 ["timing", [ "dramtmg0",  "dramtmg1",  "dramtmg2",  "dramtmg3",  "dramtmg4",  "dramtmg5",  "dramtmg8",  "odtcfg",  "rfshtmg",  ] ],
 ["mapping", [ "addrmap0",  "addrmap1",  "addrmap2",  "addrmap3",  "addrmap4",  "addrmap5",  "addrmap6",  ] ],
 ["phy", [ "dcr",  "dsgcr",  "dtcr",  "dxccr",  "pgcr2",  "zq0cr0",  "zq0cr1",  "zq1cr0",  "zq1cr1",  ] ],
 ["phy_timing", [ "dtpr0",  "dtpr1",  "dtpr2",  "ptr0",  "ptr1",  "ptr2",  "ptr3",  "ptr4",  ] ],
]);

const ddr_regs_lan966x = new Map([
 ["dfimisc", {
  help: "DFI Miscellaneous Control Register",
  fields: new Map([
 ["DFI_FREQUENCY",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 0,
	help: "Indicates the operating frequency of the system. The number of supported frequencies and the mapping of signal values to clock frequencies are defined by the PHY. Programming Mode: Quasi-dynamic Group 1",
  }],
 ["DFI_INIT_START",
  {
	pos: 5,
	width: 1,
	type: "rw",
	default: 0,
	help: "PHY init start request signal.When asserted it triggers the PHY init start request. Programming Mode: Quasi-dynamic Group 3",
  }],
 ["CTL_IDLE_EN",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Enables support of ctl_idle signal, which is non-DFI related pin specific to certain Synopsys PHYs. For more information on ctl_idle functionality, see signal description of ctl_idle signal.   Programming Mode: Static",
  }],
 ["DFI_INIT_COMPLETE_EN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 1,
	help: "PHY initialization complete enable signal. When asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation Programming Mode: Quasi-dynamic Group 3",
  }],
  ])} ],
 ["dfitmg0", {
  help: "DFI Timing Register 0",
  fields: new Map([
 ["DFI_T_CTRL_DELAY",
  {
	pos: 24,
	width: 5,
	type: "rw",
	default: 7,
	help: "Specifies the number of DFI clock cycles after an assertion or deassertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or deassertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter must be rounded up to the next integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_RDDATA_USE_DFI_PHY_CLK",
  {
	pos: 23,
	width: 1,
	type: "rw",
	default: 0,
	help: "Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR (DFI clock) or SDR (DFI PHY clock) values. Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles:  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field must be set to 0  - Else, it must be set to 1  Programming Mode: Static",
  }],
 ["DFI_T_RDDATA_EN",
  {
	pos: 16,
	width: 7,
	type: "rw",
	default: 2,
	help: "Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal. Refer to PHY specification for correct value. This corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of trddata_en. This is to compensate for the extra cycles of latency through the RDIMM/LRDIMM. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_rddata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["DFI_WRDATA_USE_DFI_PHY_CLK",
  {
	pos: 15,
	width: 1,
	type: "rw",
	default: 0,
	help: "Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR (DFI clock) or SDR (DFI PHY clock) values. Selects whether value in DFITMG0.dfi_tphy_wrlat is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles. Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles.  - 0 in terms of HDR (DFI clock) cycles  - 1 in terms of SDR (DFI PHY clock) cycles Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field must be set to 0  - Else, it must be set to 1  Programming Mode: Static",
  }],
 ["DFI_TPHY_WRDATA",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 0,
	help: "Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal. This corresponds to the DFI timing parameter tphy_wrdata. For more information on correct value, see PHY specification. Note, maximum supported value is 8. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_TPHY_WRLAT",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 2,
	help: "Write latency. Number of clocks from the write command to write data enable (dfi_wrdata_en). This corresponds to the DFI timing parameter tphy_wrlat. Refer to PHY specification for correct value.Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This is to compensate for the extra cycles of latency through the RDIMM/LRDIMM. For LPDDR4, dfi_tphy_wrlat&gt;60 is not supported. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dfitmg1", {
  help: "DFI Timing Register 1",
  fields: new Map([
 ["DFI_T_PARIN_LAT",
  {
	pos: 24,
	width: 2,
	type: "rw",
	default: 0,
	help: "Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated dfi_parity_in signal is driven. Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_T_WRDATA_DELAY",
  {
	pos: 16,
	width: 5,
	type: "rw",
	default: 0,
	help: "Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus. This corresponds to the DFI timing parameter twrdata_delay. For more information on correct value, see PHY specification. For DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0. For DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM). Value to be programmed is in terms of DFI clocks, not PHY clocks. In FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_dfi_phy_clk=1, add 1 to the value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_T_DRAM_CLK_DISABLE",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 4,
	help: "Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value. If the DFI clock and the memory clock are not phase aligned, this timing parameter must be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_T_DRAM_CLK_ENABLE",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 4,
	help: "Specifies the number of DFI clock cycles from the deassertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter must be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
  ])} ],
 ["dfiupd0", {
  help: "DFI Update Register 0",
  fields: new Map([
 ["DIS_AUTO_CTRLUPD",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 0,
	help: "When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2. The controller must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd. When '0', uMCTL2 issues dfi_ctrlupd_req periodically. Programming Mode: Quasi-dynamic Group 3",
  }],
 ["DIS_AUTO_CTRLUPD_SRX",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 0,
	help: "When '1', disable the automatic dfi_ctrlupd_req generation by the uMCTL2 at self-refresh exit. When '0', uMCTL2 issues a dfi_ctrlupd_req before or after exiting self-refresh, depending on DFIUPD0.ctrlupd_pre_srx. Programming Mode: Static",
  }],
 ["CTRLUPD_PRE_SRX",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Selects dfi_ctrlupd_req requirements at SRX:  - 0 - Send ctrlupd after SRX  - 1 - Send ctrlupd before SRX     If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req is issued when SRX.    For SNPS DDR32 PHY, keep the default value 0x0.  Programming Mode: Static",
  }],
 ["DFI_T_CTRLUP_MAX",
  {
	pos: 16,
	width: 10,
	type: "rw",
	default: 64,
	help: "Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40. Unit: DFI clock cycles. Programming Mode: Static",
  }],
 ["DFI_T_CTRLUP_MIN",
  {
	pos: 0,
	width: 10,
	type: "rw",
	default: 3,
	help: "Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time. If the PHY does not respond, the uMCTL2 deasserts dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles. Lowest value to assign to this variable is 0x1. Unit: DFI clock cycles. Programming Mode: Static",
  }],
  ])} ],
 ["dfiupd1", {
  help: "DFI Update Register 1",
  fields: new Map([
 ["DFI_T_CTRLUPD_INTERVAL_MIN_X1024",
  {
	pos: 16,
	width: 8,
	type: "rw",
	default: 1,
	help: "This is the minimum amount of time between uMCTL2 initiated DFI update requests (which is executed whenever the uMCTL2 is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the uMCTL2 is idle. The minimum allowed value for this field is 1. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
 ["DFI_T_CTRLUPD_INTERVAL_MAX_X1024",
  {
	pos: 0,
	width: 8,
	type: "rw",
	default: 1,
	help: "This is the maximum amount of time between uMCTL2 initiated DFI update requests. This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Minimum allowed value for this field is 1. Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
  ])} ],
 ["ecccfg0", {
  help: "ECC Configuration Register 0",
  fields: new Map([
 ["ECC_REGION_MAP_GRANU",
  {
	pos: 30,
	width: 2,
	type: "rw",
	default: 0,
	help: "Indicates granularity of selectable protected region. Define one region size for ECCCFG0.ecc_region_map.  - 0 - 1/8 of memory spaces   - 1 - 1/16 of memory spaces   - 2 - 1/32 of memory spaces   - 3 - 1/64 of memory spaces   Programming Mode: Static",
  }],
 ["ECC_REGION_MAP_OTHER",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "When ECCCFG0.ecc_region_map_granu&gt;0, there is a region which is not controlled by ecc_region_map. This register defines the region to be protected or non-protected for Inline ECC.  - 0 - Non-Protected  - 1 - Protected This register is valid only when ECCCFG0.ecc_region_map_granu&gt;0 &amp;&amp; ECCCFG0.ecc_mode=4.  Programming Mode: Static",
  }],
 ["ECC_AP_ERR_THRESHOLD",
  {
	pos: 24,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets threshold for address parity error. ECCAPSTAT.ecc_ap_err is asserted if number of ECC errors (correctable/uncorrectable) within one burst exceeds this threshold. This register value must be less than \"Total number of ECC checks within one burst\" when this feature is used, \"Total number of ECC check within one burst\" is calculated by (DRAM Data width) x (DRAM BL) / 64.   Programming Mode: Static",
  }],
 ["BLK_CHANNEL_IDLE_TIME_X32",
  {
	pos: 16,
	width: 6,
	type: "rw",
	default: 63,
	help: "Indicates the number of cycles on HIF interface with no access to protected regions which causes flush of all the block channels. In order to flush block channel, uMCTL2 injects write ECC command (when there is no incoming HIF command) if there is any write in the block and then stop tracking the block address.  - 0 - Indicates no timeout (feature is disabled, not supported with this version)  - 1 - Indicates 32 cycles  - 2 - Indicates 2*32 cycles, and so on  Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Quasi-dynamic Group 3",
  }],
 ["ECC_REGION_MAP",
  {
	pos: 8,
	width: 7,
	type: "rw",
	default: 127,
	help: "Selectable Protected Region setting. Memory space is divided to 8/16/32/64 regions which is determined by ECCCFG0.ecc_region_map_granu. Note: Highest 1/8 memory space is always ECC region. Lowest 7 regions are Selectable Protected Regions. The Selectable Protected Regions can be protected/non-protected selectively by ECCCFG0.ecc_region_map[6:0]. Other upper regions are non-protected region if any. Each bit of ECCCFG0.ecc_region_map[6:0] correspond to each of lowest 7 regions respectively.  In order to protect a region with ECC, set the corresponding bit to 1, otherwise set to 0. All \"0\"s is invalid - there must be at least one protected region if inline ECC is enabled through ECCCFG0.ecc_mode register. All regions are protected with the following setting.  - ecc_region_map=7'b1111111  - ecc_region_map_granu=0 Only first 1/64 region is protected with the following setting.  - ecc_region_map=7'b0000001  - ecc_region_map_granu=3  Programming Mode: Quasi-dynamic Group 3",
  }],
 ["ECC_REGION_REMAP_EN",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 0,
	help: "Enables remapping ECC region feature. Only supported when inline ECC is enabled.  - 0 - Disable  - 1 - Enable Programming Mode: Static",
  }],
 ["ECC_AP_EN",
  {
	pos: 6,
	width: 1,
	type: "rw",
	default: 1,
	help: "Enables address protection feature. Only supported when inline ECC is enabled.  - 0 - Disable  - 1 - Enable Programming Mode: Static",
  }],
 ["DIS_SCRUB",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Disables ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and MEMC_USE_RMW is defined. Note: Scrub is not supported in inline ECC mode and the register value is don't care.  Programming Mode: Static",
  }],
 ["ECC_MODE",
  {
	pos: 0,
	width: 3,
	type: "rw",
	default: 0,
	help: "ECC mode indicator.  - 000 - ECC disabled  - 100 - ECC enabled - SEC/DED over 1 beat  - 101 - ECC enabled - Advanced ECC X4/X8 (Illegal value when MEMC_INLINE_ECC=1)  - all other settings are reserved for future use Programming Mode: Static",
  }],
  ])} ],
 ["init0", {
  help: "SDRAM Initialization Register 0",
  fields: new Map([
 ["SKIP_DRAM_INIT",
  {
	pos: 30,
	width: 2,
	type: "rw",
	default: 0,
	help: "If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed.    - 00 - SDRAM Initialization routine is run after power-up  - 01 - SDRAM Initialization routine is skipped after power-up. The controller starts up in normal Mode  - 11 - SDRAM Initialization routine is skipped after power-up. The controller starts up in self-refresh Mode  - 10 - Reserved Programming Mode: Quasi-dynamic Group 2",
  }],
 ["POST_CKE_X1024",
  {
	pos: 16,
	width: 10,
	type: "rw",
	default: 2,
	help: "Indicates the number of cycles to wait after driving CKE high to start the SDRAM initialization sequence. DDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds. LPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us. LPDDR4 typically requires this to be programmed for a delay of 2 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
 ["PRE_CKE_X1024",
  {
	pos: 0,
	width: 12,
	type: "rw",
	default: 78,
	help: "Indicates the number of cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence. DDR2 specifications typically require this to be programmed for a delay of &gt;= 200 us. LPDDR2/LPDDR3: tINIT1 of 100 ns (min)  LPDDR4: tINIT3 of 2 ms (min)  When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. For DDR3/DDR4 RDIMMs, this must include the time needed to satisfy tSTAB. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
  ])} ],
 ["init1", {
  help: "SDRAM Initialization Register 1",
  fields: new Map([
 ["DRAM_RSTN_X1024",
  {
	pos: 16,
	width: 9,
	type: "rw",
	default: 0,
	help: "Indicates the number of cycles to assert SDRAM reset signal during init sequence. This is only present for designs supporting DDR3, DDR4 or LPDDR4 devices. For use with a Synopsys DDR PHY, this must be set to a minimum of 1. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
 ["PRE_OCD_X32",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "Indicates the wait period before driving the OCD complete command to SDRAM. There is no known specific requirement for this; it may be set to zero. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
  ])} ],
 ["init3", {
  help: "SDRAM Initialization Register 3",
  fields: new Map([
 ["MR",
  {
	pos: 16,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR2: Indicates the value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately. DDR3/DDR4: Value loaded into MR0 register. mDDR: Value to write to MR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["EMR",
  {
	pos: 0,
	width: 16,
	type: "rw",
	default: 1296,
	help: "DDR2: Indicates the value to write to EMR register. Bits 9:7 are for OCD and the setting in this register is ignored. The uMCTL2 sets those bits appropriately. DDR3/DDR4: Value to write to MR1 register Set bit 7 to 0. mDDR: Value to write to EMR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR2 register. Programming Mode: Quasi-dynamic Group 4",
  }],
  ])} ],
 ["init4", {
  help: "SDRAM Initialization Register 4",
  fields: new Map([
 ["EMR2",
  {
	pos: 16,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR2: Indicates the value to write to EMR2 register. DDR3/DDR4: Value to write to MR2 register. LPDDR2/LPDDR3/LPDDR4: Value to write to MR3 register. mDDR: Unused. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["EMR3",
  {
	pos: 0,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR2: Indicates the value to write to EMR3 register. DDR3/DDR4: Value to write to MR3 register. mDDR/LPDDR2/LPDDR3: Unused. LPDDR4: Value to write to MR13 register. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["init5", {
  help: "SDRAM Initialization Register 5",
  fields: new Map([
 ["DEV_ZQINIT_X32",
  {
	pos: 16,
	width: 8,
	type: "rw",
	default: 16,
	help: "ZQ initial calibration, tZQINIT. Present only in designs configured to support DDR3 or DDR4 or LPDDR2/LPDDR3. DDR3 typically requires 512 SDRAM clock cycles. DDR4 requires 1024 SDRAM clock cycles. LPDDR2/LPDDR3 requires 1 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
  ])} ],
 ["mstr", {
  help: "Master Register0",
  fields: new Map([
 ["ACTIVE_RANKS",
  {
	pos: 24,
	width: 2,
	type: "rw",
	default: 3,
	help: "Only present for multi-rank configurations. Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.  - 1 - Populated  - 0 - Unpopulated LSB is the lowest rank number. For two ranks following combinations are legal:  - 01 - One rank  - 11 - Two ranks  - Others - Reserved For four ranks following combinations are legal:  - 0001 - One rank  - 0011 - Two ranks  - 1111 - Four ranks  Programming Mode: Static",
  }],
 ["BURST_RDWR",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 4,
	help: "Indicates SDRAM burst length used:  - 0001 - Burst length of 2 (only supported for mDDR)  - 0010 - Burst length of 4  - 0100 - Burst length of 8  - 1000 - Burst length of 16 (only supported for mDDR, LPDDR2, and LPDDR4) All other values are reserved. This bit controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100) Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8. Burst length of 2 is only supported when the controller is operating in 1:1 frequency mode.  For DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8). For LPDDR4, this must be set to 0x1000 (BL16). Programming Mode: Static",
  }],
 ["DLL_OFF_MODE",
  {
	pos: 15,
	width: 1,
	type: "rw",
	default: 0,
	help: "Set to:  - 1 - When the uMCTL2 and DRAM has to be put in DLL-off mode for low frequency operation  - 0 - To put uMCTL2 and DRAM in DLL-on mode for normal frequency operation  If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode is not supported, and this bit must be set to '0'.  Programming Mode: Quasi-dynamic Group 2",
  }],
 ["DATA_BUS_WIDTH",
  {
	pos: 12,
	width: 2,
	type: "rw",
	default: 0,
	help: "Selects proportion of DQ bus width that is used by the SDRAM.  - 00 - Full DQ bus width to SDRAM  - 01 - Half DQ bus width to SDRAM  - 10 - Quarter DQ bus width to SDRAM  - 11 - Reserved Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width). Programming Mode: Static",
  }],
 ["EN_2T_TIMING_MODE",
  {
	pos: 10,
	width: 1,
	type: "rw",
	default: 0,
	help: "If 1, then uMCTL2 uses 2T timing, otherwise uses 1T timing. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command. Note:   - 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set  - 2T timing is not supported in DDR4 geardown mode  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care Programming Mode: Static",
  }],
 ["BURSTCHOP",
  {
	pos: 9,
	width: 1,
	type: "rw",
	default: 0,
	help: "When this bit is set, enables burst-chop (BC4 or 8 on-the-fly) in DDR3/DDR4. Burst Chop for reads is exercised only:  - In HIF configurations (UMCTL2_INCL_ARB not set)  - If in full bus width mode (MSTR.data_bus_width = 00)  - If MEMC_BURST_LENGTH=8 or 16 Burst Chop for writes is exercised only:  - If CRC is disabled (CRCPARCTL1.crc_enable = 0) BC4 (fixed) mode is not supported. Programming Mode: Static",
  }],
 ["DDR3",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 1,
	help: "Selects DDR3 SDRAM.  - 1 - DDR3 SDRAM device in use  - 0 - non-DDR3 SDRAM device in use Present only in designs configured to support DDR3. Programming Mode: Static",
  }],
  ])} ],
 ["pccfg", {
  help: "Port Common Configuration Register",
  fields: new Map([
 ["BL_EXP_MODE",
  {
	pos: 8,
	width: 1,
	type: "rw",
	default: 0,
	help: "Burst length expansion mode. By default (that is, bl_exp_mode==0) XPI expands every AXI burst into multiple HIF commands, using the memory burst length as a unit. If set to 1, then XPI uses half of the memory burst length as a unit. This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect. This can be used in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence, bl_exp_mode=1 is only recommended if DDR4 or LPDDR4. Note that if DBICTL.dm_en=0, functionality is not supported in the following cases:  - MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and MSTR.burst_rdwr=1000 (LPDDR4 only)  - MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and MSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or CRCPARCTL1.crc_enable=1 Functionality is also not supported if Data Channel Interleave is enabled. Programming Mode: Static",
  }],
 ["PAGEMATCH_LIMIT",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Page match four limit. If set to 1, limits the number of consecutive same page DDRC transactions that can be granted by the Port Arbiter to four when Page Match feature is enabled. If set to 0, there is no limit imposed on number of consecutive same page DDRC transactions. Programming Mode: Static",
  }],
 ["GO2CRITICAL_EN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "If set to 1 (enabled), sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master. If set to 0 (disabled), co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0. For uPCTL2, this register field must be set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["pwrctl", {
  help: "Low Power Control Register",
  fields: new Map([
 ["DIS_CAM_DRAIN_SELFREF",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 0,
	help: "Indicates whether skipping CAM draining is allowed when entering self-refresh. This register field cannot be modified while PWRCTL.selfref_sw == 1.  - 0 - CAMs must be empty before entering SR  - 1 - CAMs are not emptied before entering SR (unsupported)   Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release. PWRCTL.dis_cam_drain_selfref=0 is required.  Programming Mode: Dynamic",
  }],
 ["SELFREF_SW",
  {
	pos: 5,
	width: 1,
	type: "rw",
	default: 0,
	help: "A value of 1 to this register causes system to move to self-refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to self-refresh.  - 1 - Software Entry to self-refresh  - 0 - Software Exit from self-refresh  Programming Mode: Dynamic",
  }],
 ["EN_DFI_DRAM_CLK_DISABLE",
  {
	pos: 3,
	width: 1,
	type: "rw",
	default: 0,
	help: "Enables the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM. If set to 0, dfi_dram_clk_disable is never asserted. Assertion of dfi_dram_clk_disable is as follows: In DDR2/DDR3, can only be asserted in self-refresh. In DDR4, can be asserted in following:  - In Self-refresh  - In Maximum Power Saving Mode In mDDR/LPDDR2/LPDDR3, can be asserted in following:  - In Self-refresh  - In Power Down  - In Deep Power Down  - During Normal operation (Clock Stop) In LPDDR4, can be asserted in following:  - In Self-refresh Power Down  - In Power Down  - During Normal operation (Clock Stop)  Programming Mode: Dynamic",
  }],
 ["POWERDOWN_EN",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "If true then the uMCTL2 goes into power-down after a programmable number of cycles \"maximum idle clocks before power down\" (PWRTMG.powerdown_to_x32). This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic",
  }],
 ["SELFREF_EN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "If true then the uMCTL2 puts the SDRAM into self-refresh after a programmable number of cycles \"maximum idle clocks before self-refresh (PWRTMG.selfref_to_x32)\". This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic",
  }],
  ])} ],
 ["rfshctl0", {
  help: "Refresh Control Register 0",
  fields: new Map([
 ["REFRESH_MARGIN",
  {
	pos: 20,
	width: 4,
	type: "rw",
	default: 2,
	help: "Threshold value in number of DFI clock cycles before the critical refresh or page timer expires. A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom/32. Note that internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32 * 32 if RFSHTMG.t_rfc_nom_x1_sel=0. If RFSHTMG.t_rfc_nom_x1_sel=1 (for LPDDR2/LPDDR3/LPDDR4 per-bank refresh only), internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32. Note that, in LPDDR2/LPDDR3/LPDDR4, internally used t_rfc_nom may be divided by four if derating is enabled (DERATEEN.derate_enable=1). Unit: Multiples of 32 DFI clock cycles. Programming Mode: Dynamic - Refresh Related",
  }],
 ["REFRESH_TO_X1_X32",
  {
	pos: 12,
	width: 5,
	type: "rw",
	default: 16,
	help: "If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x1_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the uMCTL2. FOR PERFORMANCE ONLY. Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Dynamic - Refresh Related",
  }],
 ["REFRESH_BURST",
  {
	pos: 4,
	width: 6,
	type: "rw",
	default: 0,
	help: "The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.  - 0 - Single refresh  - 1 - Burst-of-2 refresh  - 7 - Burst-of-8 refresh For more information on burst refresh feature, see section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf. For DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature. In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst is due. In this situation, the refresh burst is delayed until the PHY-initiated update is complete. In per-bank refresh mode of LPDDR2/LPDDR3/LPDDR4 (RFSHCTL0.per_bank_refresh = 1), 64 refreshes can be postponed. Programming Mode: Dynamic - Refresh Related",
  }],
  ])} ],
 ["rfshctl3", {
  help: "Refresh Control Register 3",
  fields: new Map([
 ["REFRESH_UPDATE_LEVEL",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh registers have been updated. refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0). The refresh registers are automatically updated when exiting reset. Programming Mode: Dynamic",
  }],
 ["DIS_AUTO_REFRESH",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "When '1', disable auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC must generate refreshes using the registers DBGCMD.rankn_refresh. When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'. (DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode &gt; 0), disable auto-refresh is not supported, and this bit must be set to '0'. This register field is changeable on the fly. Programming Mode: Dynamic - Refresh Related",
  }],
  ])} ],
 ["dramtmg0", {
  help: "SDRAM Timing Register 0",
  fields: new Map([
 ["WR2PRE",
  {
	pos: 24,
	width: 7,
	type: "rw",
	default: 15,
	help: "Specifies the minimum time between write and precharge to same bank. Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies. where:  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present  - tWR: Write recovery time. This comes directly from the SDRAM specification Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 for this parameter. When the controller is operating in 1:2 frequency ratio mode, 1T mode, divide the previous value by 2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode, geardown mode or LPDDR4 mode, divide the previous value by 2 and round it up to the next integer value. Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. For DDR4, LPDDR4, LPDDR3, using nWR(WR) instead of tWR to calculate the value of this parameter. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["T_FAW",
  {
	pos: 16,
	width: 6,
	type: "rw",
	default: 16,
	help: "tFAW - valid only when 8 or more banks(or banks x bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_RAS_MAX",
  {
	pos: 8,
	width: 7,
	type: "rw",
	default: 27,
	help: "tRAS(max) - Specifies the maximum time between activate and precharge to same bank. This is the maximum time that a page can be kept open Minimum value of this register is 1. Zero is invalid. When the controller is operating in 1:1 frequency ratio mode, t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024). When the controller is operating in 1:2 frequency ratio mode, t_ras_max must be set to RoundDown((RoundDown(tRAS(max)/tCK/1024)-1)/2). Unit: Multiples of 1024 DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_RAS_MIN",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 15,
	help: "tRAS(min) - Specifies the minimum time between activate and precharge to the same bank. When the controller is operating in 1:1 frequency ratio mode, t_ras_min must be set to RoundUp(tRASmin/tCK) When the controller is operating in 1:2 frequency ratio mode, 1T mode, t_ras_min must be set to RoundDown(RoundUp(tRASmin/tCK)/2) When the controller is operating in 1:2 frequency ratio mode, 2T mode, geardown mode or LPDDR4 mode, t_ras min must be set to RoundUp(RoundUp(tRASmin/tCK)/2) Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg1", {
  help: "SDRAM Timing Register 1",
  fields: new Map([
 ["T_XP",
  {
	pos: 16,
	width: 5,
	type: "rw",
	default: 8,
	help: "tXP - Specifies the minimum time after power-down exit to any operation. For DDR3, this must be programmed to tXPDLL if slow powerdown exit is selected in MR0[12].  If C/A parity for DDR4 is used, set to (tXP+PL) instead.  If LPDDR4 is selected and its spec has tCKELPD parameter, set to the larger of tXP and tCKELPD instead. When the controller is operating in 1:2 frequency ratio mode, program this to (tXP/2) and round it up to the next integer value. Units: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["RD2PRE",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 4,
	help: "tRTP - Specifies the minimum time from read to precharge of same bank.  - DDR2 - tAL + BL/2 + max(RoundUp(tRTP/tCK), 2) - 2  - DDR3 - tAL + max (RoundUp(tRTP/tCK), 4)  - DDR4 - Max of following two equations:  tAL + max (RoundUp(tRTP/tCK), 4) or, RL + BL/2 - tRP (*).  - mDDR - BL/2  - LPDDR2 - Depends on if it is LPDDR2-S2 or LPDDR2-S4: LPDDR2-S2: BL/2 + RoundUp(tRTP/tCK) - 1. LPDDR2-S4: BL/2 + max(RoundUp(tRTP/tCK),2) - 2.  - LPDDR3 - BL/2 + max(RoundUp(tRTP/tCK),4) - 4  - LPDDR4 - BL/2 + max(RoundUp(tRTP/tCK),8) - 8 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP value for calculation. When the controller is operating in 1:2 mode, 1T mode, divide the previous value by 2. No rounding up.  When the controller is operating in 1:2 mode, 2T mode, geardown mode or LPDDR4 mode, divide the previous value by 2 and round it up to the next integer value. For DDR4, using RTP instead of tRTP to calculate the value of this parameter. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["T_RC",
  {
	pos: 0,
	width: 7,
	type: "rw",
	default: 20,
	help: "tRC - Specifies the minimum time between activates to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to (tRC/2) and round up to next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg2", {
  help: "SDRAM Timing Register 2",
  fields: new Map([
 ["RD2WR",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 6,
	help: "Minimum time from read command to write command. This must include time for bus turnaround (both within ranks and between ranks) and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  See the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  DDR2/3/mDDR: RL + BL/2 + 2 - WL  DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL  LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL  LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL  LPDDR4(DQ ODT is Enabled): RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RU(tODTon(min)/tCK) + 1  Where:  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - RL: Read latency = CAS latency  - WR_PREAMBLE: 1 (1tCK write preamble), 2 (2tCK write preamble). This is unique to DDR4 and LPDDR4  - RD_POSTAMBLE: 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble). This is unique to LPDDR4 For LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax must be used.  When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["WR2RD",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 13,
	help: "In DDR4, minimum time from write command to read command for same bank group. In other protoocls, minimum time from write command to read command.  This must include time for bus turn-around and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  See the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  DDR4: CWL + PL + BL/2 + tWTR_L  LPDDR2/3/4: WL + BL/2 + tWTR + 1  Others: CWL + BL/2 + tWTR  Where:  - CWL: CAS write latency  - WL: Write latency  - PL: Parity latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_L: Internal write to read command delay for same bank group. This comes directly from the SDRAM specification   - tWTR: Internal write to read command delay. This comes directly from the SDRAM specification Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation.  WTR_L must be increased by one if DDR4 2tCK write preamble is used.  When the controller is operating in 1:2 mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  If your configuration has RANKCTL1.wr2rd_dr, write to read bus turn-around between different physical ranks are controlled by RANKCTL1.wr2rd_dr.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg3", {
  help: "SDRAM Timing Register 3",
  fields: new Map([
 ["T_MRD",
  {
	pos: 12,
	width: 6,
	type: "rw",
	default: 4,
	help: "tMRD- Indicates the number of cycles to wait after a mode register write or read. Depending on the connected SDRAM, tMRD represents:  - DDR2/mDDR: Time from MRS to any command  - DDR3/4: Time from MRS to MRS command  - LPDDR2: not used  - LPDDR3/4: Time from MRS to non-MRS command  When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD/2) and round it up to the next integer value. If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat &gt; 0), tCAL (=DFITMG1.dfi_cmd_lat) must be added to the previous calculations. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_MOD",
  {
	pos: 0,
	width: 10,
	type: "rw",
	default: 12,
	help: "tMOD - Parameter used only in DDR3 and DDR4. Indicates the number of cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat &gt; 0), tCAL (=DFITMG1.dfi_cmd_lat) must be added to the previous calculations. Set to tMOD if controller is operating in 1:1 frequency ratio mode, or tMOD/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Note that if using RDIMM/LRDIMM, depending on the PHY, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency applied to mode register writes by the RDIMM/LRDIMM chip. Also note that if using RDIMM or LRDIMM, the minimum value of this register is tMRD_L2 if controller is operating in 1:1 frequency ratio mode, or tMRD_L2/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg4", {
  help: "SDRAM Timing Register 4",
  fields: new Map([
 ["T_RCD",
  {
	pos: 24,
	width: 5,
	type: "rw",
	default: 5,
	help: "tRCD - tAL: Indicates the minimum time from activate to read or write command to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to ((tRCD - tAL)/2) and round it up to the next integer value.  Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2 when the controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["T_CCD",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 4,
	help: "DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group. Others: tCCD: This is the minimum time between two reads or two writes. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_RRD",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 4,
	help: "DDR4: tRRD_L: This is the minimum time between activates from bank \"a\" to bank \"b\" for same bank group. Others: tRRD: Minimum time between activates from bank \"a\" to bank \"b\" When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_RP",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 5,
	help: "tRP: Indicates the minimum time from single-bank precharge to activate of same bank. When the controller is operating in 1:1 frequency ratio mode, t_rp must be set to RoundUp(tRP/tCK). When the controller is operating in 1:2 frequency ratio mode, t_rp must be set to RoundDown(RoundUp(tRP/tCK)/2) + 1. When the controller is operating in 1:2 frequency ratio mode in LPDDR4, t_rp must be set to RoundUp(RoundUp(tRP/tCK)/2). Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg5", {
  help: "SDRAM Timing Register 5",
  fields: new Map([
 ["T_CKSRX",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 5,
	help: "This is the time before self-refresh Exit that CK is maintained as a valid clock before issuing SRX. Specifies the clock stable time before SRX.  Recommended settings:  - mDDR - 1  - LPDDR2 - 2  - LPDDR3 - 2  - LPDDR4 - tCKCKEH  - DDR2 - 1   - DDR3 - tCKSRX   - DDR4 - tCKSRX  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_CKSRE",
  {
	pos: 16,
	width: 7,
	type: "rw",
	default: 5,
	help: "This is the time after self-refresh Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after SRE.  Recommended settings:  - mDDR - 0  - LPDDR2 - 2  - LPDDR3 - 2  - LPDDR4 - tCKELCK  - DDR2 - 1   - DDR3 - Max (10 ns, 5 tCK)  - DDR4(No RDIMM) - Max (10 ns, 5 tCK) (+ PL(parity latency)(*))  - DDR4(RDIMM)    - Max (Max (10 ns, 5 tCK) (+ PL(parity latency)(*)), tCKOff) (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_CKESR",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 4,
	help: "Indicates the minimum CKE low width for self-refresh or self-refresh power down entry to exit timing in memory clock cycles.  Recommended settings:  - mDDR - tRFC  - LPDDR2 - tCKESR  - LPDDR3 - tCKESR  - LPDDR4 - max(tCKE, tSR)  - DDR2 - tCKE   - DDR3 - tCKE + 1   - DDR4(No RDIMM) - tCKE + 1 (+ PL(parity latency)(*))  - DDR4(RDIMM)    - t_cksre + tCKEV (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_CKE",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 3,
	help: "Indicates the minimum number of cycles of CKE HIGH/LOW during power-down and self-refresh.  - LPDDR2/LPDDR3 mode - Set this to the larger of tCKE or tCKESR  - LPDDR4 mode - Set this to the larger of tCKE or tSR  - Non-LPDDR2/non-LPDDR3/non-LPDDR4 designs - Set this to tCKE value When the controller is operating in 1:2 frequency ratio mode, program this to (value described above)/2 and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg8", {
  help: "SDRAM Timing Register 8",
  fields: new Map([
 ["T_XS_DLL_X32",
  {
	pos: 8,
	width: 7,
	type: "rw",
	default: 68,
	help: "tXSDLL: Exit self-refresh to commands requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_XS_X32",
  {
	pos: 0,
	width: 7,
	type: "rw",
	default: 5,
	help: "tXS: Exit self-refresh to commands not requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["odtcfg", {
  help: "ODT Configuration Register",
  fields: new Map([
 ["WR_ODT_HOLD",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 4,
	help: "DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2. Recommended values: DDR2:  - BL8 - 0x5 (DDR2-400/533/667), 0x6 (DDR2-800), 0x7 (DDR2-1066)  - BL4 - 0x3 (DDR2-400/533/667), 0x4 (DDR2-800), 0x5 (DDR2-1066) DDR3:  - BL8 - 0x6 DDR4:   - BL8 - 5 + WR_PREAMBLE + CRC_MODE    WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble)    CRC_MODE = 0 (not CRC mode), 1 (CRC mode) LPDDR3:  - BL8 - 7 + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["WR_ODT_DELAY",
  {
	pos: 16,
	width: 5,
	type: "rw",
	default: 0,
	help: "Indicates the delay, in DFI PHY clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2. Recommended values: DDR2:  - CWL + AL - 3 (DDR2-400/533/667), CWL + AL - 4 (DDR2-800), CWL + AL - 5 (DDR2-1066)    If (CWL + AL - 3  &lt; 0), uMCTL2 does not support ODT for write operation.  DDR3:  - 0x0  DDR4:  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)   LPDDR3:  - WL - 1 - RU(tODTon(max)/tCK)) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["RD_ODT_HOLD",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 4,
	help: "DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2. Recommended values: DDR2:  - BL8 - 0x6 (not DDR2-1066), 0x7 (DDR2-1066)  - BL4 - 0x4 (not DDR2-1066), 0x5 (DDR2-1066) DDR3:  - BL8 - 0x6 DDR4:  - BL8 - 5 + RD_PREAMBLE    RD_PREAMBLE = 1 (1tCK read preamble), 2 (2tCK read preamble) LPDDR3:  - BL8 - 5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["RD_ODT_DELAY",
  {
	pos: 2,
	width: 5,
	type: "rw",
	default: 0,
	help: "Indicates the delay, in DFI PHY clock cycles, from issuing a read command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2. Recommended values: DDR2:  - CL + AL - 4 (not DDR2-1066), CL + AL - 5 (DDR2-1066)    If (CL + AL - 4 &lt; 0), uMCTL2 does not support ODT for read operation. DDR3:  - CL - CWL DDR4:  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)    WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) RD_PREAMBLE = 1 (1tCK read preamble), 2 (2tCK read preamble) If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) &lt; 0, uMCTL2 does not support ODT for read operation. LPDDR3:  - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
  ])} ],
 ["rfshtmg", {
  help: "Refresh Timing Register",
  fields: new Map([
 ["T_RFC_NOM_X1_X32",
  {
	pos: 16,
	width: 12,
	type: "rw",
	default: 98,
	help: "Average time interval between refreshes per rank (Specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR, LPDDR2, LPDDR3 and LPDDR4). When the controller is operating in 1:1 mode, set this register to RoundDown(tREFI/tCK) When the controller is operating in 1:2 mode, set this register to RoundDown(RoundDown(tREFI/tCK)/2) In both the previous cases, if RFSHTMG.t_rfc_nom_x1_sel = 0, divide the previous result by 32 and round down. For LPDDR2/LPDDR3/LPDDR4:  - If using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), use tREFIab in the previous calculations  - If using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), use tREFIpb in the previous calculations For DDR4 mode, tREFI value is different depending on the refresh mode. You must program appropriate value from the spec based on the value programmed in the refresh mode register. Note:  - RFSHTMG.t_rfc_nom_x1_x32 must be greater than 0x1  - If RFSHTMG.t_rfc_nom_x1_sel == 1, RFSHTMG.t_rfc_nom_x1_x32 must be greater than RFSHTMG.t_rfc_min  - If RFSHTMG.t_rfc_nom_x1_sel == 0, RFSHTMG.t_rfc_nom_x1_x32 * 32 must be greater than RFSHTMG.t_rfc_min  - In non-DDR4 or DDR4 Fixed 1x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0xFFE  - In DDR4 Fixed 2x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x7FF  - In DDR4 Fixed 4x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x3FF Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Dynamic - Refresh Related",
  }],
 ["T_RFC_MIN",
  {
	pos: 0,
	width: 10,
	type: "rw",
	default: 140,
	help: "tRFC (min): Minimum time from refresh to refresh or activate. When the controller is operating in 1:1 mode, t_rfc_min must be set to RoundUp(tRFCmin/tCK). When the controller is operating in 1:2 mode, t_rfc_min must be set to RoundUp(RoundUp(tRFCmin/tCK)/2). In LPDDR2/LPDDR3/LPDDR4 mode:  - If using all-bank refreshes, the tRFCmin value in the previous equations is equal to tRFCab  - If using per-bank refreshes, the tRFCmin value in the previous equations is equal to tRFCpb In DDR4 mode, the tRFCmin value in the previous equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. You must program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used. Unit: DFI clock cycles. Programming Mode: Dynamic - Refresh Related",
  }],
  ])} ],
 ["addrmap0", {
  help: "Address Map Register 0",
  fields: new Map([
 ["ADDRMAP_CS_BIT0",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as rank address bit 0. Valid Range: 0 to 29, and 31 Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then rank address bit 0 is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap1", {
  help: "Address Map Register 1",
  fields: new Map([
 ["ADDRMAP_BANK_B2",
  {
	pos: 16,
	width: 6,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as bank address bit 2. Valid Range: 0 to 31, and 63 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 2 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_BANK_B1",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as bank address bit 1. Valid Range: 0 to 32, and 63 Internal Base: 3 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 1 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_BANK_B0",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as bank address bit 0. Valid Range: 0 to 32, and 63 Internal Base: 2 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 0 is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap2", {
  help: "Address Map Register 2",
  fields: new Map([
 ["ADDRMAP_COL_B5",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 5  - Half bus width mode - Selects the HIF address bit used as column address bit 6  - Quarter bus width mode - Selects the HIF address bit used as column address bit 7  Valid Range: 0 to 7, and 15 Internal Base: 5 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B4",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 4  - Half bus width mode - Selects the HIF address bit used as column address bit 5  - Quarter bus width mode - Selects the HIF address bit used as column address bit 6 Valid Range: 0 to 7, and 15 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B3",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 3  - Half bus width mode - Selects the HIF address bit used as column address bit 4  - Quarter bus width mode - Selects the HIF address bit used as column address bit 5 Valid Range: 0 to 7, x. x indicates a valid value in the inline ECC configuration.  Internal Base: 3 The selected HIF address bit is determined by adding the internal base to the value of this field. Note, if UMCTL2_INCL_ARB=1, MEMC_BURST_LENGTH=16, Full bus width (MSTR.data_bus_width=00) and BL16 (MSTR.burst_rdwr=1000), it is recommended to program this to 0.  In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), if MEMC_BURST_LENGTH is 16, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 3 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2) Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B2",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 2  - Half bus width mode - Selects the HIF address bit used as column address bit 3  - Quarter bus width mode - Selects the HIF address bit used as column address bit 4 Valid Range: 0 to 7 Internal Base: 2 The selected HIF address bit is determined by adding the internal base to the value of this field.  Note, if UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=8, it is required to program this to 0 unless:  - In Half or Quarter bus width (MSTR.data_bus_width!=00) and  - PCCFG.bl_exp_mode==1 and either  - In DDR4 and ADDRMAP8.addrmap_bg_b0==0 or  - In LPDDR4 and ADDRMAP1.addrmap_bank_b0==0 If UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=16, it is required to program this to 0 unless:  - In Half or Quarter bus width (MSTR.data_bus_width!=00) and   - PCCFG.bl_exp_mode==1 and  - In DDR4 and ADDRMAP8.addrmap_bg_b0==0 Otherwise, if MEMC_BURST_LENGTH=8 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2. If MEMC_BURST_LENGTH=16 and Half Bus Width (MSTR.data_bus_width==01), it is recommended to program this to 0 so that HIF[2] maps to column address bit 3.  Programming Mode: Static",
  }],
  ])} ],
 ["addrmap3", {
  help: "Address Map Register 3",
  fields: new Map([
 ["ADDRMAP_COL_B9",
  {
	pos: 24,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 9  - Half bus width mode - Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode)  - Quarter bus width mode - Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode) Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 9 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 9 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 9 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 9 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B8",
  {
	pos: 16,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 8  - Half bus width mode - Selects the HIF address bit used as column address bit 9  - Quarter bus width mode - Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode) Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 8 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 8 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 8 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B7",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 7  - Half bus width mode - Selects the HIF address bit used as column address bit 8  - Quarter bus width mode - Selects the HIF address bit used as column address bit 9 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 7  The selected HIF address bit is determined by adding the internal base to the value of this field.  In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 7 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B6",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 6.  - Half bus width mode - Selects the HIF address bit used as column address bit 7.  - Quarter bus width mode - Selects the HIF address bit used as column address bit 8. Valid Range: 0 to 7, x and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then this column address bit is set to 0. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), if MEMC_BURST_LENGTH is 8, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 6 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2) Programming Mode: Static",
  }],
  ])} ],
 ["addrmap4", {
  help: "Address Map Register 4",
  fields: new Map([
 ["ADDRMAP_COL_B11",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode)  - Half bus width mode - UNUSED. See later in this description for value you need to set to make it unused  - Quarter bus width mode - UNUSED. See later in this description for value you need to set to make it unused Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 11 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 11 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 11 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 11 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B10",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode)  - Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode)  - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 10 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 10 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 10 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 10 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap5", {
  help: "Address Map Register 5",
  fields: new Map([
 ["ADDRMAP_ROW_B11",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 11. Valid Range: 0 to 11, and 15 Internal Base: 17 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 11 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B2_10",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as row address bits 2 to 10. Valid Range: 0 to 11, and 15 Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) and so on, increasing to 16 (for row address bit 10) The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. When set to 15, the values of row address bits 2 to 10 are defined by registers ADDRMAP9, ADDRMAP10, ADDRMAP11. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B1",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as row address bit 1. Valid Range: 0 to 11 Internal Base: 7 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B0",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as row address bit 0. Valid Range: 0 to 11 Internal Base: 6 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap6", {
  help: "Address Map Register 6",
  fields: new Map([
 ["ADDRMAP_ROW_B15",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 15. Valid Range: 0 to 11, and 15 Internal Base: 21 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 15 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B14",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 14. Valid Range: 0 to 11, and 15 Internal Base: 20 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 14 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B13",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 13. Valid Range: 0 to 11, and 15 Internal Base: 19 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 13 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B12",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 12. Valid Range: 0 to 11, and 15 Internal Base: 18 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 12 is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["dcr", {
  help: "DRAM Configuration Register",
  fields: new Map([
 ["UDIMM",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Un-buffered DIMM Address Mirroring: Indicates, if set, that there is address mirroring on the second rank of an un-buffered DIMM (the rank connected to CS#[1]). In this case, the PUB re-scrambles the bank and address when sending mode register commands to the second rank. This only applies to PUB internal SDRAM transactions. Transactions generated by the controller must make its own adjustments when using an un-buffered DIMM. DCR[NOSRA] must be set if address mirroring is enabled.",
  }],
 ["DDR2T",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "DDR 2T Timing: Indicates, if set, that 2T timing should be used by PUB internally generated SDRAM transactions.",
  }],
 ["NOSRA",
  {
	pos: 27,
	width: 1,
	type: "rw",
	default: 0,
	help: "No Simultaneous Rank Access: Specifies, if set, that simultaneous rank access on the same clock cycle is not allowed. This means that multiple chip select signals should not be asserted at the same time. This may be required on some DIMM systems.",
  }],
 ["BYTEMASK",
  {
	pos: 10,
	width: 8,
	type: "rw",
	default: 1,
	help: "Byte Mask: Mask applied to all beats of read data on all bytes lanes during read DQS gate training. This allows training to be conducted based on selected bit(s) from the byte lanes. Valid values for each bit are: 0 = Disable compare for that bit 1 = Enable compare for that bit Note that this mask applies in DDR3 MPR operation mode as well and must be in keeping with the PDQ field setting.",
  }],
 ["MPRDQ",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 0,
	help: "Multi-Purpose Register (MPR) DQ (DDR3 Only): Specifies the value that is driven on non-primary DQ pins during MPR reads. Valid values are: 0 = Primary DQ drives out the data from MPR (0-1-0-1); non-primary DQs drive '0' 1 = Primary DQ and non-primary DQs all drive the same data from MPR (0-1-0-1)",
  }],
 ["PDQ",
  {
	pos: 4,
	width: 3,
	type: "rw",
	default: 0,
	help: "Primary DQ (DDR3 Only): Specifies the DQ pin in a byte that is designated as a primary pin for Multi-Purpose Register (MPR) reads. Valid values are 0 to 7 for DQ[0] to DQ[7], respectively.",
  }],
 ["DDR8BNK",
  {
	pos: 3,
	width: 1,
	type: "rw",
	default: 1,
	help: "DDR 8-Bank: Indicates, if set, that the SDRAM used has 8 banks. tRPA = tRP+1 and tFAW are used for 8-bank DRAMs, otherwise tRPA = tRP and no tFAW is used. Note that a setting of 1 for DRAMs that have fewer than 8 banks results in correct functionality, but less tight DRAM command spacing for the parameters.",
  }],
 ["DDRMD",
  {
	pos: 0,
	width: 3,
	type: "rw",
	default: 3,
	help: "DDR Mode: SDRAM DDR mode. Valid values are: 000 = Reserved 001 = Reserved 010 = DDR2 011 = DDR3 100 - 111 = Reserved",
  }],
  ])} ],
 ["dsgcr", {
  help: "DDR System General Configuration Register",
  fields: new Map([
 ["CKEOE",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 1,
	help: "SDRAM CKE Output Enable: Enables, when set, the output driver on the I/O for SDRAM CKE pins.",
  }],
 ["RSTOE",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 1,
	help: "SDRAM Reset Output Enable: Enables, when set, the output driver on the I/O for SDRAM RST# pin.",
  }],
 ["ODTOE",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 1,
	help: "SDRAM ODT Output Enable: Enables, when set, the output driver on the I/O for SDRAM ODT pins.",
  }],
 ["CKOE",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 1,
	help: "SDRAM CK Output Enable: Enables, when set, the output driver on the I/O for SDRAM CK/CK# pins.",
  }],
 ["ODTPDD",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 0,
	help: "ODT Power Down Driver: Powers down, when set, the output driver on the I/O for ODT[3:0] pins. ODTPDD[0] controls the power down for ODT[0], ODTPDD[1] controls the power down for ODT[1], and so on.",
  }],
 ["CKEPDD",
  {
	pos: 20,
	width: 4,
	type: "rw",
	default: 0,
	help: "CKE Power Down Driver: Powers down, when set, the output driver on the I/O for CKE[3:0] pins. CKEPDD[0] controls the power down for CKE[0], CKEPDD[1] controls the power down for CKE[1], and so on.",
  }],
 ["SDRMODE",
  {
	pos: 19,
	width: 1,
	type: "rw",
	default: 0,
	help: "Single Data Rate Mode: Indicates, if set, that the external controller is configured to run in single data rate (SDR) mode. Otherwise if not set the controller is running in half data rate (HDR) mode. This bit not supported in the current version of the PUB.",
  }],
 ["RRMODE",
  {
	pos: 18,
	width: 1,
	type: "rw",
	default: 0,
	help: "Rise-to-Rise Mode: Indicates, if set, that the PHY mission mode is configured to run in rise-to-rise mode. Otherwise if not set the PHY mission mode is running in rise-to-fall mode.",
  }],
 ["ATOAE",
  {
	pos: 17,
	width: 1,
	type: "rw",
	default: 0,
	help: "ATO Analog Test Enable.",
  }],
 ["DTOOE",
  {
	pos: 16,
	width: 1,
	type: "rw",
	default: 0,
	help: "DTO Output Enable: Enables, when set, the output driver on the I/O for DTO pins.",
  }],
 ["DTOIOM",
  {
	pos: 15,
	width: 1,
	type: "rw",
	default: 0,
	help: "DTO I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for DTO pins.",
  }],
 ["DTOPDR",
  {
	pos: 14,
	width: 1,
	type: "rw",
	default: 1,
	help: "DTO Power Down Receiver: Powers down, when set, the input receiver on the I/O for DTO pins.",
  }],
 ["DTOPDD",
  {
	pos: 13,
	width: 1,
	type: "rw",
	default: 1,
	help: "DTO Power Down Driver: Powers down, when set, the output driver on the I/O for DTO pins.",
  }],
 ["DTOODT",
  {
	pos: 12,
	width: 1,
	type: "rw",
	default: 0,
	help: "DTO On-Die Termination: Enables, when set, the on-die termination on the I/O for DTO pins.",
  }],
 ["PUAD",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 4,
	help: "PHY Update Acknowledge Delay: Specifies the number of clock cycles that the indication for the completion of PHY update from the PHY to the controller should be delayed. This essentially delays, by this many clock cycles, the deassertion of dfi_ctrlup_ack and dfi_phyupd_req signals relative to the time when the delay lines or I/Os are updated.",
  }],
 ["BRRMODE",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 0,
	help: "Bypass Rise-to-Rise Mode: Indicates, if set, that the PHY bypass mode is configured to run in rise-to-rise mode. Otherwise if not set the PHY bypass mode is running in rise-to-fall mode.",
  }],
 ["DQSGX",
  {
	pos: 6,
	width: 1,
	type: "rw",
	default: 0,
	help: "DQS Gate Extension: Specifies, if set, that the DQS gating must be extended by two DRAM clock cycles and then re-centered, i.e. one clock cycle extension on either side.",
  }],
 ["CUAEN",
  {
	pos: 5,
	width: 1,
	type: "rw",
	default: 0,
	help: "Controller Update Acknowledge Enable: Specifies, if set, that the PHY should issue controller update acknowledge when the DFI controller update request is asserted. By default the PHY does not acknowledge controller initiated update requests but simply does an update whenever there is a controller update request. This speeds up the update.",
  }],
 ["LPPLLPD",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 1,
	help: "Low Power PLL Power Down: Specifies, if set, that the PHY should respond to the DFI low power opportunity request and power down the PLL of the byte if the wakeup time request satisfies the PLL lock time.",
  }],
 ["LPIOPD",
  {
	pos: 3,
	width: 1,
	type: "rw",
	default: 1,
	help: "Low Power I/O Power Down: Specifies, if set, that the PHY should respond to the DFI low power opportunity request and power down the I/Os of the byte.",
  }],
 ["ZUEN",
  {
	pos: 2,
	width: 1,
	type: "rw",
	default: 1,
	help: "Impedance Update Enable: Specifies, if set, that in addition to DDL VT update, the PHY could also perform impedance calibration (update). Refer to the \"Impedance Control Register 0-1 (ZQnCR0-1)\"  bit fields DFICU0, DFICU1 and DFICCU bits to control if an impedance calibration is performed (update) with a DFI controller update request. Refer to the \"Impedance Control Register 0-1 (ZQnCR0-1)\" bit fields DFIPU0 and DFIPU1 bits to control if an impedance calibration is performed (update) with a DFI PHY update request.",
  }],
 ["BDISEN",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 1,
	help: "Byte Disable Enable: Specifies, if set, that the PHY should respond to DFI byte disable request. Otherwise the byte disable from the DFI is ignored in which case bytes can only be disabled using the DXnGCR register.",
  }],
 ["PUREN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 1,
	help: "PHY Update Request Enable: Specifies if set, that the PHY should issue PHYinitiated update request when there is DDL VT drift.",
  }],
  ])} ],
 ["dtcr", {
  help: "Data Training Configuration Register",
  fields: new Map([
 ["RFSHDT",
  {
	pos: 28,
	width: 4,
	type: "rw",
	default: 9,
	help: "Refresh During Training: A non-zero value specifies that a burst of refreshes equal to the number specified in this field should be sent to the SDRAM after training each rank except the last rank.",
  }],
 ["RANKEN",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 15,
	help: "Rank Enable: Specifies the ranks that are enabled for data-training. Bit 0 controls rank 0, bit 1 controls rank 1, bit 2 controls rank 2, and bit 3 controls rank 3. Setting the bit to '1' enables the rank, and setting it to '0' disables the rank.",
  }],
 ["DTEXD",
  {
	pos: 22,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training Extended Write DQS: Enables, if set, an extended write DQS whereby two additional pulses of DQS are added as post-amble to a burst of writes. Generally this should only be enabled when running read bit deskew with the intention of performing read eye deskew prior to running write leveling adjustment.",
  }],
 ["DTDSTP",
  {
	pos: 21,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training Debug Step: A write of 1 to this bit steps the data training algorithm through a single step. This bit is used to initiate one step of the data training algorithm in question. This bit is self-clearing. To trigger the next step, this bit must be written to again. Note: The training steps must be repeated in order to get new data in the \"Data Training Eye Data Register 0-1 (DTEDR0-1)\" For example, to see the training results for a different lane, select that lane and repeat the training steps to populate DTEDR0 and DTEDR1 with the correct data.",
  }],
 ["DTDEN",
  {
	pos: 20,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training Debug Enable: Enables, if set, the data training single step debug mode.",
  }],
 ["DTDBS",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 0,
	help: "Data Training Debug Byte Select: Selects the byte during data training single step debug mode. Note: DTDEN is not used to enable this feature.",
  }],
 ["DTWDQMO",
  {
	pos: 14,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training WDQ Margin Override: If set, the Training WDQ Margin value specified in DTCR[11:8] (DTWDQM) is used during data training. Otherwise the value is computed as &#xBC; of the ddr_clk period measurement found during calibration of the WDQ LCDL.",
  }],
 ["DTBDC",
  {
	pos: 13,
	width: 1,
	type: "rw",
	default: 1,
	help: "Data Training Bit Deskew Centering: Enables, if set, eye centering capability during write and read bit deskew training.",
  }],
 ["DTWBDDM",
  {
	pos: 12,
	width: 1,
	type: "rw",
	default: 1,
	help: "Data Training Write Bit Deskew Data Mask, if set, it enables write bit deskew of the data mask.",
  }],
 ["DTWDQM",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 5,
	help: "Training WDQ Margin: Defines how close to 0 or how close to 2*(wdq calibration_value) the WDQ LCDL can be moved during training. Basically defines how much timing margin.",
  }],
 ["DTCMPD",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 1,
	help: "Read Data Training Compare Data: Specifies, if set, that DQS gate training should also check if the returning read data is correct. Otherwise data-training only checks if the correct number of DQS edges were returned.",
  }],
 ["DTMPR",
  {
	pos: 6,
	width: 1,
	type: "rw",
	default: 0,
	help: "Read Data Training Using MPR (DDR3 Only): Specifies, if set, that DQS gate training should use the SDRAM Multi-Purpose Register (MPR) register. Otherwise data-training is performed by first writing to some locations in the SDRAM and then reading them back.",
  }],
 ["DTRANK",
  {
	pos: 4,
	width: 2,
	type: "rw",
	default: 0,
	help: "Data Training Rank: Select the SDRAM rank to be used during Read DQS gate training, Read/Write Data Bit Deskew, Read/Write Eye Training.",
  }],
 ["DTRPTN",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 7,
	help: "Data Training Repeat Number: Repeat number used to confirm stability of DDR write or read. Note: The minimum value should be 0x4",
  }],
  ])} ],
 ["dxccr", {
  help: "DATX8 Common Configuration Register",
  fields: new Map([
 ["DDPDRCDO",
  {
	pos: 28,
	width: 4,
	type: "rw",
	default: 4,
	help: "Dynamic Data Power Down Receiver Count Down Offset: Offset applied in calculating window of time where receiver is powered up",
  }],
 ["DDPDDCDO",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 4,
	help: "Dynamic Data Power Down Driver Count Down Offset: Offset applied in calculating window of time where driver is powered up",
  }],
 ["DYNDXPDR",
  {
	pos: 23,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Power Down Receiver: Dynamically powers down, when set, the input receiver on I/O for the DQ pins of the active DATX8 macros. Applies only when DXPDR and DXnGCR.DXPDR are not set to 1. Receiver is powered-up on a DFI READ command and powered-down (trddata_en + fixed_read_latency + n) HDR cycles after the last DFI READ command. Note that n is defined by the register bit field DXCCR[31:28] (DDPDRCDO).",
  }],
 ["DYNDXPDD",
  {
	pos: 22,
	width: 1,
	type: "rw",
	default: 0,
	help: "Dynamic Data Power Down Driver: Dynamically powers down, when set, the output driver on I/O for the DQ pins of the active DATX8 macros. Applies only when DXPDD and DXnGCR.DXPDD are not set to 1. Driver is powered-up on a DFI WRITE command and powered-down (twrlat + WL/2 + n) HDR cycles after the last DFI WRITE command. Note that n is defined by the register bit field DXCCR[27:24] (DDPDDCDO).",
  }],
 ["UDQIOM",
  {
	pos: 21,
	width: 1,
	type: "rw",
	default: 0,
	help: "Unused DQ I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for unused DQ pins.",
  }],
 ["UDQPDR",
  {
	pos: 20,
	width: 1,
	type: "rw",
	default: 1,
	help: "Unused DQ Power Down Receiver: Powers down, when set, the input receiver on the I/O for unused DQ pins.",
  }],
 ["UDQPDD",
  {
	pos: 19,
	width: 1,
	type: "rw",
	default: 1,
	help: "Unused DQ Power Down Driver: Powers down, when set, the output driver on the I/O for unused DQ pins.",
  }],
 ["UDQODT",
  {
	pos: 18,
	width: 1,
	type: "rw",
	default: 0,
	help: "Unused DQ On-Die Termination: Enables, when set, the on-die termination on the I/O for unused DQ pins.",
  }],
 ["MSBUDQ",
  {
	pos: 15,
	width: 3,
	type: "rw",
	default: 0,
	help: "Most Significant Byte Unused DQs: Specifies the number of DQ bits that are not used in the most significant byte. The used (valid) bits for this byte are [8-MSBDQ- 1:0]. To disable the whole byte, use the DXnGCR.DXEN register.",
  }],
 ["DQSNRES",
  {
	pos: 9,
	width: 4,
	type: "rw",
	default: 12,
	help: "DQS Resistor: Selects the on-die pull-down/pull-up resistor for DQS pins. DQSRES[3] selects pull-down (when set to 0) or pull-up (when set to 1). DQSRES[2:0] selects the resistor value. Refer PHY databook for pull-down/pull-up resistor values (RA_SEL/RB_SEL) for DQS/DQS_b.",
  }],
 ["DQSRES",
  {
	pos: 5,
	width: 4,
	type: "rw",
	default: 4,
	help: "DQS Resistor: Selects the on-die pull-down/pull-up resistor for DQS pins. DQSRES[3] selects pull-down (when set to 0) or pull-up (when set to 1). DQSRES[2:0] selects the resistor value. Refer PHY databook for pull-down/pull-up resistor values (RA_SEL/RB_SEL) for DQS/DQS_b.",
  }],
 ["DXPDR",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Power Down Receiver: Powers down, when set, the input receiver on I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the PDR configuration bit of the individual DATX8.",
  }],
 ["DXPDD",
  {
	pos: 3,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Power Down Driver: Powers down, when set, the output driver on I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the PDD configuration bit of the individual DATX8.",
  }],
 ["MDLEN",
  {
	pos: 2,
	width: 1,
	type: "rw",
	default: 1,
	help: "Master Delay Line Enable: Enables, if set, all DATX8 master delay line calibration to perform subsequent period measurements following the initial period measurements that are performed after reset or on when calibration is manually triggered. These additional measurements are accumulated and filtered as long as this bit remains high. This bit is ANDed with the MDLEN bit in the individual DATX8.",
  }],
 ["DXIOM",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data I/O Mode: Selects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the IOM configuration bit of the individual DATX8.",
  }],
 ["DXODT",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data On-Die Termination: Enables, when set, the on-die termination on the I/O for DQ, DM, and DQS/DQS# pins of all DATX8 macros. This bit is ORed with the ODT configuration bit of the individual DATX8 (\"DATX8 General Configuration Register (DXnGCR)\"",
  }],
  ])} ],
 ["pgcr2", {
  help: "PHY General Configuration Register 2",
  fields: new Map([
 ["DYNACPDD",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 0,
	help: "Dynamic AC Power Down Driver: Powers down, when set, the output driver on I/O for ADDR and BA. This bit is ORed with bit ACIOCR[3] (ACPDD).",
  }],
 ["LPMSTRC0",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 0,
	help: "Low-Power Master Channel 0: set to 1 to have channel 0 act as master to drive channel 1 low-power functions simultaneously. Only valid in shared-AC mode.",
  }],
 ["ACPDDC",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "AC Power-Down with Dual Channels : Set to 1 to power-down address/command lane when both data channels are powered-down. Only valid in shared-AC mode.",
  }],
 ["SHRAC",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "Shared-AC mode: set to 1 to enable shared address/command mode with two independent data channels - available only if shared address/command mode support is compiled in.",
  }],
 ["DTPMXTMR",
  {
	pos: 20,
	width: 8,
	type: "rw",
	default: 15,
	help: "Data Training PUB Mode Timer Exit: Specifies the number of controller clocks to wait when entering and exiting pub mode data training. The default value ensures controller refreshes do not cause memory model errors when entering and exiting data training. The value should be increased if controller initiated SDRAM ZQ short or long operation may occur just before or just after the execution of data training.",
  }],
 ["FXDLAT",
  {
	pos: 19,
	width: 1,
	type: "rw",
	default: 0,
	help: "Fixed Latency: Specified whether all reads should be returned to the controller with a fixed read latency. Enabling fixed read latency increases the read latency. Valid values are: 0 = Disable fixed read latency 1 = Enable fixed read latency Fixed read latency is calculated as (12 + (maximum DXnGTR.RxDGSL)/2) HDR clock cycles",
  }],
 ["NOBUB",
  {
	pos: 18,
	width: 1,
	type: "rw",
	default: 0,
	help: "No Bubbles: Specified whether reads should be returned to the controller with no bubbles. Enabling no-bubble reads increases the read latency. Valid values are: 0 = Bubbles are allowed during reads 1 = Bubbles are not allowed during reads",
  }],
 ["TREFPRD",
  {
	pos: 0,
	width: 18,
	type: "rw",
	default: 74880,
	help: "Refresh Period: Indicates the period in clock cycles after which the PUB has to issue a refresh command to the SDRAM. This is derived from the maximum refresh interval from the datasheet, tRFC(max) or REFI, divided by the clock cycle time. A further 400 clocks must be subtracted from the derived number to account for command flow and missed slots of refreshes in the internal PUB blocks. The default corresponds to DDR3 9*7.8us at 1066MHz when a burst of 9 refreshes are issued at every refresh interval.",
  }],
  ])} ],
 ["zq0cr0", {
  help: "ZQ n Impedance Control Register 0",
  fields: new Map([
 ["ZQ0_ZQPD",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 0,
	help: "ZQ Power Down: Powers down, if set, the PZQ cell.",
  }],
 ["ZQ0_ZCALEN",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 1,
	help: "Impedance Calibration Enable: Enables, if set, the impedance calibration of this ZQ control block when impedance calibration is triggered using either the ZCAL bit of PIR register or the DFI update interface.",
  }],
 ["ZQ0_ZCALBYP",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Impedance Calibration Bypass: Bypasses, if set, impedance calibration of this ZQ control block when impedance calibration is already in progress. Impedance calibration can be disabled prior to trigger by using the ZCALEN bit.",
  }],
 ["ZQ0_ZDEN",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "Impedance Over-ride Enable: When this bit is set, it allows users to directly drive the impedance control using the data programmed in the ZDATA field. Otherwise, the control is generated automatically by the impedance control logic.",
  }],
 ["ZQ0_ZDATA",
  {
	pos: 0,
	width: 28,
	type: "rw",
	default: 330,
	help: "Impedance Over-Ride Data: Data used to directly drive the impedance control. ZDATA field mapping for D3F I/Os is as follows: ZDATA[27:21] is used to select the pull-up on-die termination impedance ZDATA[20:14] is used to select the pull-down on-die termination impedance ZDATA[13:7] is used to select the pull-up output impedance ZDATA[6:0] is used to select the pull-down output impedance ZDATA field mapping for D3A/B/R I/Os is as follows: ZDATA[27:20] is reserved and returns zeros on reads ZDATA[19:15] is used to select the pull-up on-die termination impedance ZDATA[14:10] is used to select the pull-down on-die termination impedance ZDATA[9:5] is used to select the pull-up output impedance ZDATA[4:0] is used to select the pull-down output impedance The default value is 0x000014A for I/O type D3C/R and 0x0001830 for I/O type D3F.",
  }],
  ])} ],
 ["zq0cr1", {
  help: "ZQ n Impedance Control Register 1",
  fields: new Map([
 ["ZQ0_DFIPU1",
  {
	pos: 17,
	width: 1,
	type: "rw",
	default: 0,
	help: "DFI Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 1 (channel 1) requests an update. Only valid in shared-AC mode.",
  }],
 ["ZQ0_DFIPU0",
  {
	pos: 16,
	width: 1,
	type: "rw",
	default: 0,
	help: "DFI Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 0 (channel 0) requests an update.",
  }],
 ["ZQ0_DFICCU",
  {
	pos: 14,
	width: 1,
	type: "rw",
	default: 0,
	help: "DFI Concurrent Controller Update Interface: Sets this impedance controller to be enabled for calibration when both of the DFI controller update interfaces request an update on the same clock. This provides the ability to enable impedance calibration updates for the Address/Command lane. Only valid in shared-AC mode.",
  }],
 ["ZQ0_DFICU1",
  {
	pos: 13,
	width: 1,
	type: "rw",
	default: 0,
	help: "DFI Controller Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 1 (channel 1) requests an update.",
  }],
 ["ZQ0_DFICU0",
  {
	pos: 12,
	width: 1,
	type: "rw",
	default: 1,
	help: "DFI Controller Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 0 (channel 0) requests an update.",
  }],
 ["ZQ0_ZPROG",
  {
	pos: 0,
	width: 8,
	type: "rw",
	default: 123,
	help: "Impedance Divide Ratio: Selects the external resistor divide ratio to be used to set the output impedance and the on-die termination as follows: ZPROG[7:4] = On-die termination divide select ZPROG[3:0] = Output impedance divide select",
  }],
  ])} ],
 ["zq1cr0", {
  help: "ZQ n Impedance Control Register 0",
  fields: new Map([
 ["ZQ1_ZQPD",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 0,
	help: "ZQ Power Down: Powers down, if set, the PZQ cell.",
  }],
 ["ZQ1_ZCALEN",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 1,
	help: "Impedance Calibration Enable: Enables, if set, the impedance calibration of this ZQ control block when impedance calibration is triggered using either the ZCAL bit of PIR register or the DFI update interface.",
  }],
 ["ZQ1_ZCALBYP",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Impedance Calibration Bypass: Bypasses, if set, impedance calibration of this ZQ control block when impedance calibration is already in progress. Impedance calibration can be disabled prior to trigger by using the ZCALEN bit.",
  }],
 ["ZQ1_ZDEN",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "Impedance Over-ride Enable: When this bit is set, it allows users to directly drive the impedance control using the data programmed in the ZDATA field. Otherwise, the control is generated automatically by the impedance control logic.",
  }],
 ["ZQ1_ZDATA",
  {
	pos: 0,
	width: 28,
	type: "rw",
	default: 330,
	help: "Impedance Over-Ride Data: Data used to directly drive the impedance control. ZDATA field mapping for D3F I/Os is as follows: ZDATA[27:21] is used to select the pull-up on-die termination impedance ZDATA[20:14] is used to select the pull-down on-die termination impedance ZDATA[13:7] is used to select the pull-up output impedance ZDATA[6:0] is used to select the pull-down output impedance ZDATA field mapping for D3A/B/R I/Os is as follows: ZDATA[27:20] is reserved and returns zeros on reads ZDATA[19:15] is used to select the pull-up on-die termination impedance ZDATA[14:10] is used to select the pull-down on-die termination impedance ZDATA[9:5] is used to select the pull-up output impedance ZDATA[4:0] is used to select the pull-down output impedance The default value is 0x000014A for I/O type D3C/R and 0x0001830 for I/O type D3F.",
  }],
  ])} ],
 ["zq1cr1", {
  help: "ZQ n Impedance Control Register 1",
  fields: new Map([
 ["ZQ1_DFIPU1",
  {
	pos: 17,
	width: 1,
	type: "rw",
	default: 0,
	help: "DFI Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 1 (channel 1) requests an update. Only valid in shared-AC mode.",
  }],
 ["ZQ1_DFIPU0",
  {
	pos: 16,
	width: 1,
	type: "rw",
	default: 0,
	help: "DFI Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI PHY update interface 0 (channel 0) requests an update.",
  }],
 ["ZQ1_DFICCU",
  {
	pos: 14,
	width: 1,
	type: "rw",
	default: 0,
	help: "DFI Concurrent Controller Update Interface: Sets this impedance controller to be enabled for calibration when both of the DFI controller update interfaces request an update on the same clock. This provides the ability to enable impedance calibration updates for the Address/Command lane. Only valid in shared-AC mode.",
  }],
 ["ZQ1_DFICU1",
  {
	pos: 13,
	width: 1,
	type: "rw",
	default: 0,
	help: "DFI Controller Update Interface 1: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 1 (channel 1) requests an update.",
  }],
 ["ZQ1_DFICU0",
  {
	pos: 12,
	width: 1,
	type: "rw",
	default: 1,
	help: "DFI Controller Update Interface 0: Sets this impedance controller to be enabled for calibration when the DFI controller update interface 0 (channel 0) requests an update.",
  }],
 ["ZQ1_ZPROG",
  {
	pos: 0,
	width: 8,
	type: "rw",
	default: 123,
	help: "Impedance Divide Ratio: Selects the external resistor divide ratio to be used to set the output impedance and the on-die termination as follows: ZPROG[7:4] = On-die termination divide select ZPROG[3:0] = Output impedance divide select",
  }],
  ])} ],
 ["dtpr0", {
  help: "DRAM Timing Parameters Register 0",
  fields: new Map([
 ["TRC",
  {
	pos: 26,
	width: 6,
	type: "rw",
	default: 50,
	help: "Activate to activate command delay (same bank). Valid values are 2 to 63.",
  }],
 ["TRRD",
  {
	pos: 22,
	width: 4,
	type: "rw",
	default: 7,
	help: "Activate to activate command delay (different banks). Valid values are 1 to 15.",
  }],
 ["TRAS",
  {
	pos: 16,
	width: 6,
	type: "rw",
	default: 36,
	help: "Activate to precharge command delay. Valid values are 2 to 63.",
  }],
 ["TRCD",
  {
	pos: 12,
	width: 4,
	type: "rw",
	default: 14,
	help: "Activate to read or write delay. Minimum time from when an activate command is issued to when a read or write to the activated row can be issued. Valid values are 2 to 15.",
  }],
 ["TRP",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 14,
	help: "Precharge command period: The minimum time between a precharge command and any other command. Note that the Controller automatically derives tRPA for 8- bank DDR2 devices by adding 1 to tRP. Valid values are 2 to 15.",
  }],
 ["TWTR",
  {
	pos: 4,
	width: 4,
	type: "rw",
	default: 8,
	help: "Internal write to read command delay. Valid values are 1 to 15.",
  }],
 ["TRTP",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 8,
	help: "Internal read to precharge command delay. Valid values are 2 to 15.",
  }],
  ])} ],
 ["dtpr1", {
  help: "DRAM Timing Parameters Register 1",
  fields: new Map([
 ["TAON_OFF_D",
  {
	pos: 30,
	width: 2,
	type: "rw",
	default: 0,
	help: "ODT turn-on/turn-off delays (DDR2 only). The delays are in clock cycles. Valid values are: 00 = 2/2.5 01 = 3/3.5 10 = 4/4.5 11 = 5/5.5 Most DDR2 devices utilize a fixed value of 2/2.5. For non-standard SDRAMs, the user must ensure that the operational Write Latency is always greater than or equal to the ODT turn-on delay. For example, a DDR2 SDRAM with CAS latency set to 3 and CAS additive latency set to 0 has a Write Latency of 2. Thus 2/2.5 can be used, but not 3/3.5 or higher.",
  }],
 ["TWLO",
  {
	pos: 26,
	width: 4,
	type: "rw",
	default: 8,
	help: "Write leveling output delay: Number of clock cycles from when write leveling DQS is driven high by the control block to when the results from the SDRAM on DQ is sampled by the control block. This must include the SDRAM tWLO timing parameter plus the round trip delay from control block to SDRAM back to control block.",
  }],
 ["TWLMRD",
  {
	pos: 20,
	width: 6,
	type: "rw",
	default: 40,
	help: "Minimum delay from when write leveling mode is programmed to the first DQS/DQS# rising edge.",
  }],
 ["TRFC",
  {
	pos: 11,
	width: 9,
	type: "rw",
	default: 374,
	help: "Refresh-to-Refresh: Indicates the minimum time, in clock cycles, between two refresh commands or between a refresh and an active command. This is derived from the minimum refresh interval from the datasheet, tRFC(min), divided by the clock cycle time. The default number of clock cycles is for the largest JEDEC tRFC(min parameter value supported.",
  }],
 ["TFAW",
  {
	pos: 5,
	width: 6,
	type: "rw",
	default: 38,
	help: "4-bank activate period. No more than 4-bank activate commands may be issued in a given tFAW period. Only applies to 8-bank devices. Valid values are 2 to 63.",
  }],
 ["TMOD",
  {
	pos: 2,
	width: 3,
	type: "rw",
	default: 4,
	help: "Load mode update delay (DDR3 only). The minimum time between a load mode register command and a non-load mode register command. Valid values are: 000 = 12 001 = 13 010 = 14 011 = 15 100 = 16 101 = 17 110 - 111 = Reserved.",
  }],
 ["TMRD",
  {
	pos: 0,
	width: 2,
	type: "rw",
	default: 2,
	help: "Load mode cycle time: The minimum time between a load mode register command and any other command. For DDR3 this is the minimum time between two load mode register commands. Valid values for DDR2 are 2 to 3. For DDR3, the value used for tMRD is 4 plus the value programmed in these bits, i.e. tMRD value for DDR3 ranges from 4 to 7.",
  }],
  ])} ],
 ["dtpr2", {
  help: "DRAM Timing Parameters Register 2",
  fields: new Map([
 ["TCCD",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 0,
	help: "Read to read and write to write command delay. Valid values are: 0 = BL/2 for DDR2 and 4 for DDR3 1 = BL/2 + 1 for DDR2 and 5 for DDR3",
  }],
 ["TRTW",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 0,
	help: "Read to Write command delay. Valid values are: 0 = standard bus turn around delay 1 = add 1 clock to standard bus turn around delay This parameter allows the user to increase the delay between issuing Write commands to the SDRAM when preceded by Read commands. This provides an option to increase bus turn-around margin for high frequency systems.",
  }],
 ["TRTODT",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Read to ODT delay (DDR3 only). Specifies whether ODT can be enabled immediately after the read post-amble or one clock delay has to be added. Valid values are: 0 = ODT may be turned on immediately after read post-amble 1 = ODT may not be turned on until one clock after the read post-amble If tRTODT is set to 1, then the read-to-write latency is increased by 1 if ODT is enabled.",
  }],
 ["TDLLK",
  {
	pos: 19,
	width: 10,
	type: "rw",
	default: 512,
	help: "DLL locking time. Valid values are 2 to 1023.",
  }],
 ["TCKE",
  {
	pos: 15,
	width: 4,
	type: "rw",
	default: 6,
	help: "CKE minimum pulse width. Also specifies the minimum time that the SDRAM must remain in power down or self refresh mode. For DDR3 this parameter must be set to the value of tCKESR which is usually bigger than the value of tCKE. Valid values are 2 to 15.",
  }],
 ["TXP",
  {
	pos: 10,
	width: 5,
	type: "rw",
	default: 26,
	help: "Power down exit delay. The minimum time between a power down exit command and any other command. This parameter must be set to the maximum of the various minimum power down exit delay parameters specified in the SDRAM datasheet, i.e. max(tXP, tXARD, tXARDS) for DDR2 and max(tXP, tXPDLL) for DDR3. Valid values are 2 to 31.",
  }],
 ["TXS",
  {
	pos: 0,
	width: 10,
	type: "rw",
	default: 512,
	help: "Self refresh exit delay. The minimum time between a self refresh exit command and any other command. This parameter must be set to the maximum of the various minimum self refresh exit delay parameters specified in the SDRAM datasheet, i.e. max(tXSNR, tXSRD) for DDR2 and max(tXS, tXSDLL) for DDR3. Valid values are 2 to 1023.",
  }],
  ])} ],
 ["ptr0", {
  help: "PHY Timing Register 0",
  fields: new Map([
 ["TPLLPD",
  {
	pos: 21,
	width: 11,
	type: "rw",
	default: 534,
	help: "PLL Power-Down Time: Number of configuration or APB clock cycles that the PLL must remain in power-down mode, i.e. number of clock cycles from when PLL power-down pin is asserted to when PLL power-down pin is deasserted. This must correspond to a value that is equal to or more than 1us. Default value corresponds to 1us.",
  }],
 ["TPLLGS",
  {
	pos: 6,
	width: 15,
	type: "rw",
	default: 2134,
	help: "PLL Gear Shift Time: Number of configuration or APB clock cycles from when the PLL reset pin is deasserted to when the PLL gear shift pin is deasserted. This must correspond to a value that is equal to or more than 4us. Default value corresponds to 4us.",
  }],
 ["TPHYRST",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 16,
	help: "PHY Reset Time: Number of configuration or APB clock cycles that the PHY reset must remain asserted after PHY calibration is done before the reset to the PHY is deasserted. This is used to extend the reset to the PHY so that the reset is asserted for some clock cycles after the clocks are stable. Valid values are from 1 to 63 (the value must be non-zero).",
  }],
  ])} ],
 ["ptr1", {
  help: "PHY Timing Register 1",
  fields: new Map([
 ["TPLLLOCK",
  {
	pos: 16,
	width: 16,
	type: "rw",
	default: 53334,
	help: "PLL Lock Time: Number of configuration or APB clock cycles for the PLL to stabilize and lock, i.e. number of clock cycles from when the PLL reset pin is deasserted to when the PLL has lock and is ready for use. This must correspond to a value that is equal to or more than 100us. Default value corresponds to 100us.",
  }],
 ["TPLLRST",
  {
	pos: 0,
	width: 13,
	type: "rw",
	default: 4800,
	help: "PLL Reset Time: Number of configuration or APB clock cycles that the PLL must remain in reset mode, i.e. number of clock cycles from when PLL power-down pin is deasserted and PLL reset pin is asserted to when PLL reset pin is deasserted. The setting must correspond to a value that is equal to, or greater than, 3us.",
  }],
  ])} ],
 ["ptr2", {
  help: "PHY Timing Register 2",
  fields: new Map([
 ["TWLDLYS",
  {
	pos: 15,
	width: 5,
	type: "rw",
	default: 16,
	help: "Write Leveling Delay Settling Time: Number of controller clock cycles from when a new value of the write leveling delay is applies to the LCDL to when to DQS high is driven high. This allows the delay to settle.",
  }],
 ["TCALH",
  {
	pos: 10,
	width: 5,
	type: "rw",
	default: 15,
	help: "Calibration Hold Time: Number of controller clock cycles from when the clock was disabled (cal_clk_en deasserted) to when calibration is enable (cal_en asserted).",
  }],
 ["TCALS",
  {
	pos: 5,
	width: 5,
	type: "rw",
	default: 15,
	help: "Calibration Setup Time: Number of controller clock cycles from when calibration is enabled (cal_en asserted) to when the calibration clock is asserted again (cal_clk_en asserted).",
  }],
 ["TCALON",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 15,
	help: "Calibration On Time: Number of clock cycles that the calibration clock is enabled (cal_clk_en asserted).",
  }],
  ])} ],
 ["ptr3", {
  help: "PHY Timing Register 3",
  fields: new Map([
 ["TDINIT1",
  {
	pos: 20,
	width: 10,
	type: "rw",
	default: 384,
	help: "DRAM Initialization Time 1: DRAM initialization time in DRAM clock cycles corresponding to the following: DDR3 = CKE high time to first command (tRFC + 10 ns or 5 tCK, whichever is bigger) DDR2 = CKE high time to first command (400 ns) Default value corresponds to DDR3 tRFC of 360ns at 1066 MHz.",
  }],
 ["TDINIT0",
  {
	pos: 0,
	width: 20,
	type: "rw",
	default: 533334,
	help: "DRAM Initialization Time 0: DRAM initialization time in DRAM clock cycles corresponding to the following: DDR3 = CKE low time with power and clock stable (500 us) DDR2 = CKE low time with power and clock stable (200 us) Default value corresponds to DDR3 500 us at 1066 MHz. During Verilog simulations, it is recommended that this value is changed to a much smaller value in order to avoid long simulation times. However, this may cause a memory model error, due to a violation of the CKE setup sequence. This violation is expected if this value is not programmed to the required SDRAM CKE low time, but memory models should be able to tolerate this violation without malfunction of the model.",
  }],
  ])} ],
 ["ptr4", {
  help: "PHY Timing Register 4",
  fields: new Map([
 ["TDINIT3",
  {
	pos: 18,
	width: 10,
	type: "rw",
	default: 683,
	help: "DRAM Initialization Time 3: DRAM initialization time in DRAM clock cycles corresponding to the following: DDR3 = Time from ZQ initialization command to first command (1 us) Default value corresponds to the DDR3 640ns at 1066 MHz.",
  }],
 ["TDINIT2",
  {
	pos: 0,
	width: 18,
	type: "rw",
	default: 213334,
	help: "DRAM Initialization Time 2: DRAM initialization time in DRAM clock cycles corresponding to the following: DDR3 = Reset low time (200 us on power-up or 100 ns after power-up) Default value corresponds to DDR3 200 us at 1066 MHz.",
  }],
  ])} ],
]);

const ddr_diag_regs_lan966x = new Map([
 ["dx0gsr0", 0xe00841c4],
 ["dx0gsr1", 0xe00841c8],
 ["dx0gsr2", 0xe00841f4],
 ["dx1gsr0", 0xe0084204],
 ["dx1gsr1", 0xe0084208],
 ["dx1gsr2", 0xe0084234],
 ["dx0lcdlr0", 0xe00841e0],
 ["dx0lcdlr1", 0xe00841e4],
 ["dx0lcdlr2", 0xe00841e8],
 ["dx1lcdlr0", 0xe0084220],
 ["dx1lcdlr1", 0xe0084224],
 ["dx1lcdlr2", 0xe0084228],
 ["zq0cr0", 0xe0084180],
 ["zq0cr1", 0xe0084184],
 ["zq0sr0", 0xe0084188],
 ["zq0sr1", 0xe008418c],
 ["zq1cr0", 0xe0084190],
 ["zq1cr1", 0xe0084194],
 ["zq1sr0", 0xe0084198],
 ["zq1sr1", 0xe008419c],
]);
