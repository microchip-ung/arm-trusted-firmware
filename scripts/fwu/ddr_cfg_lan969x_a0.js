/*
 * Copyright (C) 2022 Microchip Technology Inc. and its subsidiaries.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

const ddr_cfg_lan969x = new Map([
 ["info", ["version", "speed", "mem_size_mb", "bus_width"]],
 ["main", [ "crcparctl1",  "dbictl",  "dfimisc",  "dfitmg0",  "dfitmg1",  "dfiupd0",  "dfiupd1",  "ecccfg0",  "init0",  "init1",  "init3",  "init4",  "init5",  "init6",  "init7",  "mstr",  "pccfg",  "pwrctl",  "rfshctl0",  "rfshctl3",  ] ],
 ["timing", [ "dramtmg0",  "dramtmg1",  "dramtmg12",  "dramtmg2",  "dramtmg3",  "dramtmg4",  "dramtmg5",  "dramtmg8",  "dramtmg9",  "odtcfg",  "rfshtmg",  ] ],
 ["mapping", [ "addrmap0",  "addrmap1",  "addrmap2",  "addrmap3",  "addrmap4",  "addrmap5",  "addrmap6",  "addrmap7",  "addrmap8",  ] ],
 ["phy", [ "dcr",  "dsgcr",  "dtcr0",  "dtcr1",  "dxccr",  "pgcr2",  "schcr1",  "zq0pr",  "zq1pr",  "zq2pr",  "zqcr",  ] ],
 ["phy_timing", [ "dtpr0",  "dtpr1",  "dtpr2",  "dtpr3",  "dtpr4",  "dtpr5",  "ptr0",  "ptr1",  "ptr2",  "ptr3",  "ptr4",  ] ],
]);

const ddr_regs_lan969x = new Map([
 ["crcparctl1", {
  help: "CRC Parity Control Register 1",
  fields: new Map([
 ["PARITY_ENABLE",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "C/A Parity enable register.    If RCD's parity error detection or SDRAM's parity detection is enabled, this register must be 1. Programming Mode: Static",
  }],
 ["CRC_ENABLE",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "CRC enable Register.    The setting of this register must match the CRC mode register setting in the DRAM. Programming Mode: Quasi-dynamic Group 2",
  }],
 ["CRC_INC_DM",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 0,
	help: "CRC calculation setting register.    Present only in designs configured to support DDR4. Programming Mode: Static",
  }],
 ["CAPARITY_DISABLE_BEFORE_SR",
  {
	pos: 12,
	width: 1,
	type: "rw",
	default: 1,
	help: "If DDR4-SDRAM's CA parity is enabled by INIT6.mr5[2:0]!=0 and this register is set to 1, CA parity is automatically disabled before self-refresh entry, and enabled after self-refresh exit by issuing MR5.    If Geardown is used by MSTR.geardown_mode=1, this register must be set to 1. If this register set to 0, DRAMTMG5.t_ckesr and DRAMTMG5.t_cksre must be increased by PL(Parity latency). Programming Mode: Static",
  }],
  ])} ],
 ["dbictl", {
  help: "DM/DBI Control Register",
  fields: new Map([
 ["DM_EN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 1,
	help: "Indicates the DM enable signal in DDRC.    This signal must be set the same logical value as DRAM's mode register.  - DDR4 - Set this to same value as MR5 bit A10. When x4 devices are used, this signal must be set to 0  - LPDDR4 - Set this to inverted value of MR13[5] which is opposite polarity from this signal Programming Mode: Static",
  }],
 ["WR_DBI_EN",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "Write DBI enable signal in DDRC.    This signal must be set the same value as DRAM's mode register.  - DDR4 - MR5 bit A11. When x4 devices are used, this signal must be set to 0  - LPDDR4 - MR3[7] Programming Mode: Quasi-dynamic Group 1",
  }],
 ["RD_DBI_EN",
  {
	pos: 2,
	width: 1,
	type: "rw",
	default: 0,
	help: "Read DBI enable signal in DDRC.    This signal must be set the same value as DRAM's mode register.  - DDR4 - MR5 bit A12. When x4 devices are used, this signal must be set to 0  - LPDDR4 - MR3[6] Programming Mode: Quasi-dynamic Group 1",
  }],
  ])} ],
 ["dfimisc", {
  help: "DFI Miscellaneous Control Register",
  fields: new Map([
 ["DFI_INIT_COMPLETE_EN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 1,
	help: "PHY initialization complete enable signal. Programming Mode: Quasi-dynamic Group 3",
  }],
 ["PHY_DBI_MODE",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "DBI implemented in DDRC or PHY.    Present only in designs configured to support DDR4 and LPDDR4. Programming Mode: Static",
  }],
 ["CTL_IDLE_EN",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets support of ctl_idle signal, which is non-DFI related pin specific to certain Synopsys PHYs. For more information on ctl_idle functionality, see signal description of ctl_idle signal.   Programming Mode: Static",
  }],
 ["DFI_INIT_START",
  {
	pos: 5,
	width: 1,
	type: "rw",
	default: 0,
	help: "PHY init start request signal. Programming Mode: Quasi-dynamic Group 3",
  }],
 ["DIS_DYN_ADR_TRI",
  {
	pos: 6,
	width: 1,
	type: "rw",
	default: 1,
	help: "Sets PHY specific Dynamic Tristating. This functionality works only in DFI 1:2 frequency ratio mode regardless of MSTR.en_2t_timing_mode, so if either of the following condition is met no special IDLE command is issued on the DFI bus:  - MEMC_FREQ_RATIO==1  - MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1 The special IDLE command means the following codes with the case where all the dfi_cs is 1:  - (phase 0 and 1) dfi_ras_n=1  - (phase 0 and 1) dfi_cas_n= 1  - phase 0 and 1) dfi_we_n= 1  - (phase 0 and 1) dfi_bank [0]= 0  - (phase 0 and 1) dfi_act_n= 1 Programming Mode: Quasi-dynamic Group 3",
  }],
 ["DFI_FREQUENCY",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 0,
	help: "Indicates the operating frequency of the system. The number of supported frequencies and the mapping of signal values to clock frequencies are defined by the PHY. Programming Mode: Quasi-dynamic Group 1",
  }],
  ])} ],
 ["dfitmg0", {
  help: "DFI Timing Register 0",
  fields: new Map([
 ["DFI_TPHY_WRLAT",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 2,
	help: "Write latency. Number of clocks from the write command to write data enable (dfi_wrdata_en). This corresponds to the DFI timing parameter tphy_wrlat. Refer to PHY specification for correct value.Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of tphy_wrlat. This is to compensate for the extra cycles of latency through the RDIMM/LRDIMM. For LPDDR4, dfi_tphy_wrlat&gt;60 is not supported. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["DFI_TPHY_WRDATA",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 0,
	help: "Specifies the number of clock cycles between when dfi_wrdata_en is asserted to when the associated write data is driven on the dfi_wrdata signal. This corresponds to the DFI timing parameter tphy_wrdata. For more information on correct value, see PHY specification. Note, maximum supported value is 8. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_wrdata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_WRDATA_USE_DFI_PHY_CLK",
  {
	pos: 15,
	width: 1,
	type: "rw",
	default: 0,
	help: "Defines whether dfi_wrdata_en/dfi_wrdata/dfi_wrdata_mask is generated using HDR (DFI clock) or SDR (DFI PHY clock) values. Selects whether value in DFITMG0.dfi_tphy_wrlat is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles. Selects whether value in DFITMG0.dfi_tphy_wrdata is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles.    Refer to PHY specification for correct value.   If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field must be set to 0  - Else, it must be set to 1  Programming Mode: Static",
  }],
 ["DFI_T_RDDATA_EN",
  {
	pos: 16,
	width: 7,
	type: "rw",
	default: 2,
	help: "Time from the assertion of a read command on the DFI interface to the assertion of the dfi_rddata_en signal. Refer to PHY specification for correct value. This corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of trddata_en. This is to compensate for the extra cycles of latency through the RDIMM/LRDIMM. Unit: DFI clock cycles or DFI PHY clock cycles, depending on DFITMG0.dfi_rddata_use_dfi_phy_clk. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["DFI_RDDATA_USE_DFI_PHY_CLK",
  {
	pos: 23,
	width: 1,
	type: "rw",
	default: 0,
	help: "Defines whether dfi_rddata_en/dfi_rddata/dfi_rddata_valid is generated using HDR (DFI clock) or SDR (DFI PHY clock) values. Selects whether value in DFITMG0.dfi_t_rddata_en is in terms of HDR (DFI clock) or SDR (DFI PHY clock) cycles.    Refer to PHY specification for correct value. If using a Synopsys DWC DDR3/2 PHY, DWC DDR2/3-Lite/mDDR PHY, DWC DDR multiPHY or DWC Gen2 DDR multiPHY, this field must be set to 0; otherwise:  - If MEMC_PROG_FREQ_RATIO=1 and MSTR.frequency_ratio=1, this field must be set to 0  - Else, it must be set to 1  Programming Mode: Static",
  }],
 ["DFI_T_CTRL_DELAY",
  {
	pos: 24,
	width: 5,
	type: "rw",
	default: 7,
	help: "Specifies the number of DFI clock cycles after an assertion or de-assertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect the assertion or de-assertion. If the DFI clock and the memory clock are not phase-aligned, this timing parameter must be rounded up to the next integer value. Note that if using RDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra cycle of latency in terms of DFI clock. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
  ])} ],
 ["dfitmg1", {
  help: "DFI Timing Register 1",
  fields: new Map([
 ["DFI_T_DRAM_CLK_ENABLE",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 4,
	help: "Specifies the number of DFI clock cycles from the de-assertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the clock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the memory clock are not phase aligned, this timing parameter must be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_T_DRAM_CLK_DISABLE",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 4,
	help: "Specifies the number of DFI clock cycles from the assertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory devices, at the PHY-DRAM boundary, maintains a low value. If the DFI clock and the memory clock are not phase aligned, this timing parameter must be rounded up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_T_WRDATA_DELAY",
  {
	pos: 16,
	width: 5,
	type: "rw",
	default: 0,
	help: "Specifies the number of DFI clock cycles between when the dfi_wrdata_en signal is asserted and when the corresponding write data transfer is completed on the DRAM bus. This corresponds to the DFI timing parameter twrdata_delay. For more information on correct value, see PHY specification. For DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0. For DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM). Value to be programmed is in terms of DFI clocks, not PHY clocks. In FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer. If using DFITMG0.dfi_wrdata_use_dfi_phy_clk=1, add 1 to the value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_T_PARIN_LAT",
  {
	pos: 24,
	width: 2,
	type: "rw",
	default: 0,
	help: "Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated dfi_parity_in signal is driven. Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["DFI_T_CMD_LAT",
  {
	pos: 28,
	width: 4,
	type: "rw",
	default: 0,
	help: "Specifies the number of DFI PHY clock cycles between when the dfi_cs signal is asserted and when the associated command is driven. This field is used for CAL mode, must be set to '0' or tCAL, which matches the CAL mode register setting in the DRAM. When enabling CAL mode with RDIMM/LRDIMM, this field must be set to tCAL-CLA (Command Latency Adder). For more information on CLA, see JEDEC DDR4 Register Specification. If the PHY can add the latency for CAL mode, this must be set to '0'. Valid Range: 0 to 8. Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dfiupd0", {
  help: "DFI Update Register 0",
  fields: new Map([
 ["DFI_T_CTRLUP_MIN",
  {
	pos: 0,
	width: 10,
	type: "rw",
	default: 3,
	help: "Specifies the minimum number of DFI clock cycles that the dfi_ctrlupd_req signal must be asserted. The uMCTL2 expects the PHY to respond within this time. If the PHY does not respond, the uMCTL2 de-asserts dfi_ctrlupd_req after dfi_t_ctrlup_min + 2 cycles. Lowest value to assign to this variable is 0x1. Unit: DFI clock cycles. Programming Mode: Static",
  }],
 ["DFI_T_CTRLUP_MAX",
  {
	pos: 16,
	width: 10,
	type: "rw",
	default: 64,
	help: "Specifies the maximum number of DFI clock cycles that the dfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40. Unit: DFI clock cycles. Programming Mode: Static",
  }],
 ["CTRLUPD_PRE_SRX",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Selects dfi_ctrlupd_req requirements at SRX.    If DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req is issued when SRX. Programming Mode: Static",
  }],
 ["DIS_AUTO_CTRLUPD_SRX",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets the automatic dfi_ctrlupd_req generation by the uMCTL2 at self-refresh exit. Programming Mode: Static",
  }],
 ["DIS_AUTO_CTRLUPD",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets the automatic dfi_ctrlupd_req generation by the uMCTL2. The controller must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd.  Programming Mode: Quasi-dynamic Group 3",
  }],
  ])} ],
 ["dfiupd1", {
  help: "DFI Update Register 1",
  fields: new Map([
 ["DFI_T_CTRLUPD_INTERVAL_MAX_X1024",
  {
	pos: 0,
	width: 8,
	type: "rw",
	default: 1,
	help: "This is the maximum amount of time between uMCTL2 initiated DFI update requests. This timer resets with each update request; when the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is received. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI controller update is also used to reset PHY FIFO pointers in case of data capture errors. Updates are required to maintain calibration over PVT, but frequent updates may impact performance. Minimum allowed value for this field is 1. Note: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than DFIUPD1.dfi_t_ctrlupd_interval_min_x1024. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
 ["DFI_T_CTRLUPD_INTERVAL_MIN_X1024",
  {
	pos: 16,
	width: 8,
	type: "rw",
	default: 1,
	help: "This is the minimum amount of time between uMCTL2 initiated DFI update requests (which is executed whenever the uMCTL2 is idle). Set this number higher to reduce the frequency of update requests, which can have a small impact on the latency of the first read request when the uMCTL2 is idle. The minimum allowed value for this field is 1. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
  ])} ],
 ["ecccfg0", {
  help: "ECC Configuration Register 0",
  fields: new Map([
 ["ECC_MODE",
  {
	pos: 0,
	width: 3,
	type: "rw",
	default: 0,
	help: "ECC mode indicator. Everything not described in \"Values\" section is reserved. Programming Mode: Static",
  }],
 ["DIS_SCRUB",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Disables ECC scrubs. Valid only when ECCCFG0.ecc_mode = 3'b100 or 3'b101 and MEMC_USE_RMW is defined. Note: Scrub is not supported in inline ECC mode and the register value is don't care.  Programming Mode: Static",
  }],
 ["ECC_AP_EN",
  {
	pos: 6,
	width: 1,
	type: "rw",
	default: 1,
	help: "Enables address protection feature. Only supported when inline ECC is enabled. Programming Mode: Static",
  }],
 ["ECC_REGION_REMAP_EN",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 0,
	help: "Enables remapping ECC region feature. Only supported when inline ECC is enabled. Programming Mode: Static",
  }],
 ["ECC_REGION_MAP",
  {
	pos: 8,
	width: 7,
	type: "rw",
	default: 127,
	help: "Selectable Protected Region setting. Memory space is divided to 8/16/32/64 regions which is determined by ECCCFG0.ecc_region_map_granu. Note: Highest 1/8 memory space is always ECC region. Lowest 7 regions are Selectable Protected Regions. The Selectable Protected Regions can be protected/non-protected selectively by ECCCFG0.ecc_region_map[6:0]. Other upper regions are non-protected region if any. Each bit of ECCCFG0.ecc_region_map[6:0] correspond to each of lowest 7 regions respectively.  In order to protect a region with ECC, set the corresponding bit to 1, otherwise set to 0. All \"0\"s is invalid - there must be at least one protected region if inline ECC is enabled through ECCCFG0.ecc_mode register. All regions are protected with the following setting.  - ecc_region_map=7'b1111111  - ecc_region_map_granu=0 Only first 1/64 region is protected with the following setting.  - ecc_region_map=7'b0000001  - ecc_region_map_granu=3  Programming Mode: Quasi-dynamic Group 3",
  }],
 ["BLK_CHANNEL_IDLE_TIME_X32",
  {
	pos: 16,
	width: 6,
	type: "rw",
	default: 63,
	help: "Indicates the number of cycles on HIF interface with no access to protected regions which causes flush of all the block channels. In order to flush block channel, uMCTL2 injects write ECC command (when there is no incoming HIF command) if there is any write in the block and then stop tracking the block address.  - 0 - Indicates no timeout (feature is disabled, not supported with this version)  - 1 - Indicates 32 cycles  - 2 - Indicates 2*32 cycles, and so on  Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Quasi-dynamic Group 3",
  }],
 ["ECC_AP_ERR_THRESHOLD",
  {
	pos: 24,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets threshold for address parity error. ECCAPSTAT.ecc_ap_err is asserted if number of ECC errors (correctable/uncorrectable) within one burst exceeds this threshold. This register value must be less than \"Total number of ECC checks within one burst\" when this feature is used, \"Total number of ECC check within one burst\" is calculated by (DRAM Data width) x (DRAM BL) / 64.   Programming Mode: Static",
  }],
 ["ECC_REGION_MAP_OTHER",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "When ECCCFG0.ecc_region_map_granu&gt;0, there is a region which is not controlled by ecc_region_map. This register defines the region to be protected or non-protected for Inline ECC.    This register is valid only when ECCCFG0.ecc_region_map_granu&gt;0 &amp;&amp; ECCCFG0.ecc_mode=4.  Programming Mode: Static",
  }],
 ["ECC_REGION_MAP_GRANU",
  {
	pos: 30,
	width: 2,
	type: "rw",
	default: 0,
	help: "Indicates granularity of selectable protected region. Define one region size for ECCCFG0.ecc_region_map. Programming Mode: Static",
  }],
  ])} ],
 ["init0", {
  help: "SDRAM Initialization Register 0",
  fields: new Map([
 ["PRE_CKE_X1024",
  {
	pos: 0,
	width: 12,
	type: "rw",
	default: 78,
	help: "Indicates the number of cycles to wait after reset before driving CKE high to start the SDRAM initialization sequence. DDR2 specifications typically require this to be programmed for a delay of &gt;= 200 us. LPDDR2/LPDDR3: tINIT1 of 100 ns (min)  LPDDR4: tINIT3 of 2 ms (min)  When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. For DDR3/DDR4 RDIMMs, this must include the time needed to satisfy tSTAB. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
 ["POST_CKE_X1024",
  {
	pos: 16,
	width: 10,
	type: "rw",
	default: 2,
	help: "Indicates the number of cycles to wait after driving CKE high to start the SDRAM initialization sequence. DDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock speeds. LPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us. LPDDR4 typically requires this to be programmed for a delay of 2 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
 ["SKIP_DRAM_INIT",
  {
	pos: 30,
	width: 2,
	type: "rw",
	default: 0,
	help: "If lower bit is enabled the SDRAM initialization routine is skipped. The upper bit decides what state the controller starts up in when reset is removed. Value \"10\" is reserved. Programming Mode: Quasi-dynamic Group 2",
  }],
  ])} ],
 ["init1", {
  help: "SDRAM Initialization Register 1",
  fields: new Map([
 ["PRE_OCD_X32",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "Indicates the wait period before driving the OCD complete command to SDRAM. There is no known specific requirement for this; it may be set to zero. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
 ["DRAM_RSTN_X1024",
  {
	pos: 16,
	width: 9,
	type: "rw",
	default: 0,
	help: "Indicates the number of cycles to assert SDRAM reset signal during init sequence. This is only present for designs supporting DDR3, DDR4 or LPDDR4 devices. For use with a Synopsys DDR PHY, this must be set to a minimum of 1. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 1024 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
  ])} ],
 ["init3", {
  help: "SDRAM Initialization Register 3",
  fields: new Map([
 ["EMR",
  {
	pos: 0,
	width: 16,
	type: "rw",
	default: 1296,
	help: "DDR2: Indicates the value to write to EMR register. Bits 9:7 are for OCD and the setting in this register is ignored. The uMCTL2 sets those bits appropriately. DDR3/DDR4: Value to write to MR1 register Set bit 7 to 0. mDDR: Value to write to EMR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR2 register. Programming Mode: Quasi-dynamic Group 4",
  }],
 ["MR",
  {
	pos: 16,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR2:Indicates the value to write to MR register. Bit 8 is for DLL and the setting here is ignored. The uMCTL2 sets this bit appropriately. DDR3/DDR4: Value loaded into MR0 register. mDDR: Value to write to MR register. LPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
  ])} ],
 ["init4", {
  help: "SDRAM Initialization Register 4",
  fields: new Map([
 ["EMR3",
  {
	pos: 0,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR2: Indicates the value to write to EMR3 register. DDR3/DDR4: Value to write to MR3 register. mDDR/LPDDR2/LPDDR3: Unused. LPDDR4: Value to write to MR13 register. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["EMR2",
  {
	pos: 16,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR2: Indicates the value to write to EMR2 register. DDR3/DDR4: Value to write to MR2 register. LPDDR2/LPDDR3/LPDDR4: Value to write to MR3 register. mDDR: Unused. Programming Mode: Quasi-dynamic Group 4",
  }],
  ])} ],
 ["init5", {
  help: "SDRAM Initialization Register 5",
  fields: new Map([
 ["DEV_ZQINIT_X32",
  {
	pos: 16,
	width: 8,
	type: "rw",
	default: 16,
	help: "ZQ initial calibration, tZQINIT. Present only in designs configured to support DDR3 or DDR4 or LPDDR2/LPDDR3. DDR3 typically requires 512 SDRAM clock cycles. DDR4 requires 1024 SDRAM clock cycles. LPDDR2/LPDDR3 requires 1 us. When the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec value divided by 2, and round it up to the next integer value. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Static",
  }],
  ])} ],
 ["init6", {
  help: "SDRAM Initialization Register 6",
  fields: new Map([
 ["MR5",
  {
	pos: 0,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR4 - Indicates the value to be loaded into SDRAM MR5 registers. LPDDR4- Value to be loaded into SDRAM MR12 registers. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["MR4",
  {
	pos: 16,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR4 - Indicates the value to be loaded into SDRAM MR4 registers. LPDDR4- Value to be loaded into SDRAM MR11 registers. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["init7", {
  help: "SDRAM Initialization Register 7",
  fields: new Map([
 ["MR6",
  {
	pos: 0,
	width: 16,
	type: "rw",
	default: 0,
	help: "DDR4 - Indicates the value to be loaded into SDRAM MR6 registers. LPDDR4- Value to be loaded into SDRAM MR14 registers. Programming Mode: Quasi-dynamic Group 4",
  }],
  ])} ],
 ["mstr", {
  help: "Master Register 0",
  fields: new Map([
 ["DDR3",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 1,
	help: "Selects DDR3 SDRAM.   Present only in designs configured to support DDR3. Programming Mode: Static",
  }],
 ["DDR4",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Selects DDR4 SDRAM.   Present only in designs configured to support DDR4. Programming Mode: Static",
  }],
 ["BURSTCHOP",
  {
	pos: 9,
	width: 1,
	type: "rw",
	default: 0,
	help: "Enables Burst Chop(BC4 or 8 on-the-fly) in DDR3/DDR4. Burst Chop for reads is exercised only:  - In HIF configurations (UMCTL2_INCL_ARB not set)  - If in full bus width mode (MSTR.data_bus_width = 00)  - If MEMC_BURST_LENGTH=8 or 16 Burst Chop for writes is exercised only:  - If CRC is disabled (CRCPARCTL1.crc_enable = 0) BC4 (fixed) mode is not supported. Programming Mode: Static",
  }],
 ["EN_2T_TIMING_MODE",
  {
	pos: 10,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets uMCTL2 timing mode. In 2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus. Chip select is asserted on the second cycle of the command. Note:   - 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode  - 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set  - 2T timing is not supported in DDR4 geardown mode  - 2T timing is not supported in Shared-AC dual channel mode and the register value is don't care Programming Mode: Static",
  }],
 ["GEARDOWN_MODE",
  {
	pos: 11,
	width: 1,
	type: "rw",
	default: 0,
	help: "Indicates the DRAM in geardown mode.   This register can be changed, only when the controller is in the self-refresh mode. This signal must be set the same value as MR3 bit A3.  Note:   - Geardown mode is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set  - Geardown mode is not supported if the configuration parameter UMCTL2_SHARED_AC is set (in Shared-AC mode) and the register value is don't care Programming Mode: Quasi-dynamic Group 2",
  }],
 ["DATA_BUS_WIDTH",
  {
	pos: 12,
	width: 2,
	type: "rw",
	default: 0,
	help: "Selects proportion of DQ bus width that is used by the SDRAM.    Note that half bus width mode is only supported when the SDRAM bus width is a multiple of 16, and quarter bus width mode is only supported when the SDRAM bus width is a multiple of 32 and the configuration parameter MEMC_QBUS_SUPPORT is set. Bus width refers to DQ bus width (excluding any ECC width). Programming Mode: Static",
  }],
 ["DLL_OFF_MODE",
  {
	pos: 15,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets DLL-off mode. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode is not supported, and this bit must be set to '0'. Programming Mode: Quasi-dynamic Group 2",
  }],
 ["BURST_RDWR",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 4,
	help: "Indicates SDRAM burst length used.    All other values are reserved.(See \"Values\" section) This bit controls the burst size used to access the SDRAM. This must match the burst length mode register setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to 0x0100) Burst length of 2 is not supported with AXI ports when MEMC_BURST_LENGTH is 8. Burst length of 2 is only supported when the controller is operating in 1:1 frequency mode.  For DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8). For LPDDR4, this must be set to 0x1000 (BL16). Programming Mode: Static",
  }],
 ["ACTIVE_RANKS",
  {
	pos: 24,
	width: 2,
	type: "rw",
	default: 3,
	help: "Only present for multi-rank configurations. Each bit represents one rank. For two-rank configurations, only bits[25:24] are present.  - 1 - Populated  - 0 - Unpopulated LSB is the lowest rank number. For two ranks only the following values are legal:  - OneRank  - Tworanks  - Others  - Reserved For four ranks following combinations are legal:  - 0001 - One rank  - 0011 - Two ranks  - 1111 - Four ranks  Programming Mode: Static",
  }],
 ["DEVICE_CONFIG",
  {
	pos: 30,
	width: 2,
	type: "rw",
	default: 0,
	help: "Indicates the configuration of the device used in the system. Programming Mode: Static",
  }],
  ])} ],
 ["pccfg", {
  help: "Port Common Configuration Register",
  fields: new Map([
 ["GO2CRITICAL_EN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "If enabled, sets co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input (awurgent, arurgent) coming from AXI master. If disabled, co_gs_go2critical_wr and co_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0. For uPCTL2, this register field must be set to 0. Programming Mode: Static",
  }],
 ["PAGEMATCH_LIMIT",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Page match four limit. Programming Mode: Static",
  }],
 ["BL_EXP_MODE",
  {
	pos: 8,
	width: 1,
	type: "rw",
	default: 0,
	help: "Burst length expansion mode. This applies to both reads and writes. When MSTR.data_bus_width==00, setting bl_exp_mode to 1 has no effect. This can be used in order to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence, bl_exp_mode=1 is only recommended if DDR4 or LPDDR4. Note that if DBICTL.dm_en=0, functionality is not supported in the following cases:  - MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and MSTR.burst_rdwr=1000 (LPDDR4 only)  - MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and MSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or CRCPARCTL1.crc_enable=1 Functionality is also not supported if Data Channel Interleave is enabled. Programming Mode: Static",
  }],
  ])} ],
 ["pwrctl", {
  help: "Low Power Control Register",
  fields: new Map([
 ["SELFREF_EN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets Self-refresh. This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic",
  }],
 ["POWERDOWN_EN",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets Power-down mode. This register bit may be re-programmed during the course of normal operation. Programming Mode: Dynamic",
  }],
 ["EN_DFI_DRAM_CLK_DISABLE",
  {
	pos: 3,
	width: 1,
	type: "rw",
	default: 0,
	help: "Enables the assertion of dfi_dram_clk_disable whenever a clock is not required by the SDRAM. Assertion of dfi_dram_clk_disable is as follows: In DDR2/DDR3, can only be asserted in self-refresh. In DDR4, can be asserted in following:  - In Self-refresh  - In Maximum Power Saving Mode In mDDR/LPDDR2/LPDDR3, can be asserted in following:  - In Self-refresh  - In Power Down  - In Deep Power Down  - During Normal operation (Clock Stop) In LPDDR4, can be asserted in following:  - In Self-refresh Power Down  - In Power Down  - During Normal operation (Clock Stop)  Programming Mode: Dynamic",
  }],
 ["MPSM_EN",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 0,
	help: "Sets Maximum powersaving mode. Present only in designs configured to support DDR4. For non-DDR4, this register must not be set to 1. Note that MPSM is not supported when using a Synopsys DWC DDR PHY, if the PHY parameter DWC_AC_CS_USE is disabled, as the MPSM exit sequence requires the chip-select signal to toggle. FOR PERFORMANCE ONLY. Programming Mode: Dynamic",
  }],
 ["SELFREF_SW",
  {
	pos: 5,
	width: 1,
	type: "rw",
	default: 0,
	help: "A value of 1 to this register causes system to move to self-refresh state immediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as Software Entry/Exit to self-refresh.  Programming Mode: Dynamic",
  }],
 ["DIS_CAM_DRAIN_SELFREF",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 0,
	help: "Indicates whether skipping CAM draining is allowed when entering self-refresh. This register field cannot be modified while PWRCTL.selfref_sw == 1.    Note, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release. PWRCTL.dis_cam_drain_selfref=0 is required.  Programming Mode: Dynamic",
  }],
  ])} ],
 ["rfshctl0", {
  help: "Refresh Control Register 0",
  fields: new Map([
 ["REFRESH_BURST",
  {
	pos: 4,
	width: 6,
	type: "rw",
	default: 0,
	help: "The programmed value + 1 is the number of refresh timeouts that is allowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing pages to perform a refresh is a one-time penalty that must be paid for each group of refreshes. Therefore, performing refreshes in a burst reduces the per-refresh penalty of these page closings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower numbers decreases the worst-case latency associated with refreshes.  - 0 - Single refresh  - 1 - Burst-of-2 refresh  - 7 - Burst-of-8 refresh For more information on burst refresh feature, see section 3.9 of DDR2 JEDEC specification - JESD79-2F.pdf. For DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be accumulated over 8*tREFI cycles using the burst refresh feature. In DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X mode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates, care must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not violated due to a PHY-initiated update occurring shortly before a refresh burst is due. In this situation, the refresh burst is delayed until the PHY-initiated update is complete. In per-bank refresh mode of LPDDR2/LPDDR3/LPDDR4 (RFSHCTL0.per_bank_refresh = 1), 64 refreshes can be postponed. In LPDDR4 mode, if per-bank refresh is enabled (RFSHCTL0.per_bank_refresh = 1), and automatic switching from per-bank to all-bank refresh is enabled (RFSHCTL0.auto_refab_en = 2'b01 or RFSHCTL0.auto_refab_en = 2'b10), the uCMTL2 divides this value by 8 when it switches automatically from per-bank to all-bank refresh. Programming Mode: Dynamic - Refresh Related",
  }],
 ["REFRESH_TO_X1_X32",
  {
	pos: 12,
	width: 5,
	type: "rw",
	default: 16,
	help: "If the refresh timer (tRFCnom, also known as tREFI) has expired at least once, then a speculative refresh may be performed. A speculative refresh is a refresh performed at a time when refresh would be useful. When the SDRAM bus is idle for a period of time determined by this RFSHCTL0.refresh_to_x1_x32 and the refresh timer has expired at least once since the last refresh, then a speculative refresh is performed. Speculative refreshes continues successively until there are no refreshes pending or until new reads or writes are issued to the uMCTL2. FOR PERFORMANCE ONLY. Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Dynamic - Refresh Related",
  }],
 ["REFRESH_MARGIN",
  {
	pos: 20,
	width: 4,
	type: "rw",
	default: 2,
	help: "Threshold value in number of DFI clock cycles before the critical refresh or page timer expires. A critical refresh is to be issued before this threshold is reached. It is recommended that this not be changed from the default value, currently shown as 0x2. It must always be less than internally used t_rfc_nom/32. Note that internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32 * 32 if RFSHTMG.t_rfc_nom_x1_sel=0. If RFSHTMG.t_rfc_nom_x1_sel=1 (for LPDDR2/LPDDR3/LPDDR4 per-bank refresh only), internally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32. Note that, in LPDDR2/LPDDR3/LPDDR4, internally used t_rfc_nom may be divided by four if derating is enabled (DERATEEN.derate_enable=1). Unit: Multiples of 32 DFI clock cycles. Programming Mode: Dynamic - Refresh Related",
  }],
  ])} ],
 ["rfshctl3", {
  help: "Refresh Control Register 3",
  fields: new Map([
 ["DIS_AUTO_REFRESH",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "Disables auto-refresh generated by the uMCTL2. When auto-refresh is disabled, the SoC must generate refreshes using the registers DBGCMD.rankn_refresh. When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the uMCTL2. If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'. (DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode &gt; 0), disable auto-refresh is not supported, and this bit must be set to '0'. This register field is changeable on the fly. Programming Mode: Dynamic - Refresh Related",
  }],
 ["REFRESH_UPDATE_LEVEL",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh registers have been updated. refresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0). The refresh registers are automatically updated when exiting reset. Programming Mode: Dynamic",
  }],
 ["REFRESH_MODE",
  {
	pos: 4,
	width: 3,
	type: "rw",
	default: 0,
	help: "Indicates fine granularity refresh mode. Everything not described in \"Values\" section is reserved.  Note:   - Only Fixed 1x mode is supported if RFSHCTL3.dis_auto_refresh = 1  - The on-the-fly modes are not supported in this version of the uMCTL2  - This must be set up while the controller is in reset or while the controller is in self-refresh mode. Changing this during normal operation is not allowed. Making this a dynamic register is supported in future version of the uMCTL2  - This register field has effect only if a DDR4 SDRAM device is in use (MSTR.ddr4 = 1) Programming Mode: Quasi-dynamic Group 2",
  }],
  ])} ],
 ["dramtmg0", {
  help: "SDRAM Timing Register 0",
  fields: new Map([
 ["T_RAS_MIN",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 15,
	help: "tRAS(min) - Specifies the minimum time between activate and precharge to the same bank. When the controller is operating in 1:1 frequency ratio mode, t_ras_min must be set to RoundUp(tRASmin/tCK) When the controller is operating in 1:2 frequency ratio mode, 1T mode, t_ras_min must be set to RoundDown(RoundUp(tRASmin/tCK)/2) When the controller is operating in 1:2 frequency ratio mode, 2T mode, geardown mode or LPDDR4 mode, t_ras min must be set to RoundUp(RoundUp(tRASmin/tCK)/2) Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_RAS_MAX",
  {
	pos: 8,
	width: 7,
	type: "rw",
	default: 27,
	help: "tRAS(max) - Specifies the maximum time between activate and precharge to same bank. This is the maximum time that a page can be kept open Minimum value of this register is 1. Zero is invalid. When the controller is operating in 1:1 frequency ratio mode, t_ras_max must be set to RoundDown(tRAS(max)/tCK/1024). When the controller is operating in 1:2 frequency ratio mode, t_ras_max must be set to RoundDown((RoundDown(tRAS(max)/tCK/1024)-1)/2). Unit: Multiples of 1024 DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_FAW",
  {
	pos: 16,
	width: 6,
	type: "rw",
	default: 16,
	help: "tFAW - valid only when 8 or more banks(or banks x bank groups) are present. In 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles. When the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and round up to next integer value. In a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["WR2PRE",
  {
	pos: 24,
	width: 7,
	type: "rw",
	default: 15,
	help: "Specifies the minimum time between write and precharge to same bank. Specifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and less for lower frequencies. where:  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM. BST (burst terminate) is not supported at present  - tWR: Write recovery time. This comes directly from the SDRAM specification Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 for this parameter. When the controller is operating in 1:2 frequency ratio mode, 1T mode, divide the previous value by 2. No rounding up. When the controller is operating in 1:2 frequency ratio mode, 2T mode, geardown mode or LPDDR4 mode, divide the previous value by 2 and round it up to the next integer value. Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. For DDR4, LPDDR4, LPDDR3, using nWR(WR) instead of tWR to calculate the value of this parameter. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg1", {
  help: "SDRAM Timing Register 1",
  fields: new Map([
 ["T_RC",
  {
	pos: 0,
	width: 7,
	type: "rw",
	default: 20,
	help: "tRC - Specifies the minimum time between activates to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to (tRC/2) and round up to next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["RD2PRE",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 4,
	help: "tRTP - Specifies the minimum time from read to precharge of same bank.  - DDR2 - tAL + BL/2 + max(RoundUp(tRTP/tCK), 2) - 2  - DDR3 - tAL + max (RoundUp(tRTP/tCK), 4)  - DDR4 - Max of following two equations:  tAL + max (RoundUp(tRTP/tCK), 4) or, RL + BL/2 - tRP (*).  - mDDR - BL/2  - LPDDR2 - Depends on if it is LPDDR2-S2 or LPDDR2-S4: LPDDR2-S2: BL/2 + RoundUp(tRTP/tCK) - 1. LPDDR2-S4: BL/2 + max(RoundUp(tRTP/tCK),2) - 2.  - LPDDR3 - BL/2 + max(RoundUp(tRTP/tCK),4) - 4  - LPDDR4 - BL/2 + max(RoundUp(tRTP/tCK),8) - 8 (*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP value for calculation. When the controller is operating in 1:2 mode, 1T mode, divide the previous value by 2. No rounding up.  When the controller is operating in 1:2 mode, 2T mode, geardown mode or LPDDR4 mode, divide the previous value by 2 and round it up to the next integer value. For DDR4, using RTP instead of tRTP to calculate the value of this parameter. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["T_XP",
  {
	pos: 16,
	width: 5,
	type: "rw",
	default: 8,
	help: "tXP - Specifies the minimum time after power-down exit to any operation. For DDR3, this must be programmed to tXPDLL if slow powerdown exit is selected in MR0[12].  If C/A parity for DDR4 is used, set to (tXP+PL) instead.  If LPDDR4 is selected and its spec has tCKELPD parameter, set to the larger of tXP and tCKELPD instead. When the controller is operating in 1:2 frequency ratio mode, program this to (tXP/2) and round it up to the next integer value. Units: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg12", {
  help: "SDRAM Timing Register 12",
  fields: new Map([
 ["T_MRD_PDA",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 16,
	help: "tMRD_PDA: This is the Mode Register Set command cycle time in PDA mode. When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD_PDA/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_WR_MPR",
  {
	pos: 24,
	width: 6,
	type: "rw",
	default: 26,
	help: "This bit is used only in DDR4. Cycles between MPR Write and other command. Set this to tMOD + AL (or tMOD + PL + AL if C/A parity is also used).  When the controller is operating in 1:2 frequency ratio mode, program this to (tWR_MPR/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg2", {
  help: "SDRAM Timing Register 2",
  fields: new Map([
 ["WR2RD",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 13,
	help: "In DDR4, minimum time from write command to read command for same bank group. In other protoocls, minimum time from write command to read command.  This must include time for bus turn-around and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  Please see the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  DDR4: CWL + BL/2 + tWTR_L  LPDDR2/3/4: WL + BL/2 + tWTR + 1  Others: CWL + BL/2 + tWTR  Where:  - CWL: CAS write latency  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_L: Internal write to read command delay for same bank group. This comes directly from the SDRAM specification   - tWTR: Internal write to read command delay. This comes directly from the SDRAM specification Add one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation.  WTR_L must be increased by one if DDR4 2tCK write preamble is used.  When the controller is operating in 1:2 mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  If your configuration has RANKCTL1.wr2rd_dr, write to read bus turn-around between different physical ranks are controlled by RANKCTL1.wr2rd_dr.  Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["RD2WR",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 6,
	help: "Minimum time from read command to write command. This must include time for bus turnaround (both within ranks and between ranks) and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  Please see the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  DDR2/3/mDDR: RL + BL/2 + 2 - WL  DDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL  LPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL  LPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE + RD_POSTAMBLE - WL  LPDDR4(DQ ODT is Enabled): RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE - ODTLon - RD(tODTon(min)/tCK) + 1  Where:  - WL: Write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - RL: Read latency = CAS latency  - WR_PREAMBLE: 1 (1tCK write preamble), 2 (2tCK write preamble). This is unique to DDR4 and LPDDR4  - RD_POSTAMBLE: 0.5 (0.5tCK read postamble), 1.5 (1.5tCK read postamble). This is unique to LPDDR4 For LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated tDQSCKmax must be used.  When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  Note that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency through the LRDIMM. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["READ_LATENCY",
  {
	pos: 16,
	width: 6,
	type: "rw",
	default: 5,
	help: "Set this field to RL. Indicates the time from read command to read data on SDRAM interface. This must be set to RL. Note that, depending on the PHY, if using RDIMM/LRDIMM, it might be necessary to adjust the value of RL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the previous equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["WRITE_LATENCY",
  {
	pos: 24,
	width: 6,
	type: "rw",
	default: 3,
	help: "Set this field to WL. Indicates the Time from write command to write data on SDRAM interface. This must be set to WL. For mDDR, it must  be set to 1. Note that, depending on the PHY, if using RDIMM/LRDIMM, it might be necessary to adjust the value of WL to compensate for the extra cycle of latency through the RDIMM/LRDIMM. When the controller is operating in 1:2 frequency ratio mode, divide the value calculated using the previous equation by 2, and round it up to next integer. This register field is not required for DDR2 and DDR3, as the DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those protocols For all protocols, in addition to programming this register field, it is necessary to program DFITMG0 and DFITMG1 to control the read and write latencies Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg3", {
  help: "SDRAM Timing Register 3",
  fields: new Map([
 ["T_MOD",
  {
	pos: 0,
	width: 10,
	type: "rw",
	default: 12,
	help: "tMOD - Parameter used only in DDR3 and DDR4. Indicates the number of cycles between load mode command and following non-load mode command. If C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat &gt; 0), tCAL (=DFITMG1.dfi_cmd_lat) must be added to the previous calculations. Set to tMOD if controller is operating in 1:1 frequency ratio mode, or tMOD/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Note that if using RDIMM/LRDIMM, depending on the PHY, it may be necessary to adjust the value of this parameter to compensate for the extra cycle of latency applied to mode register writes by the RDIMM/LRDIMM chip. Also note that if using LRDIMM, the minimum value of this register is tMRD_L2 if controller is operating in 1:1 frequency ratio mode, or tMRD_L2/2 (rounded up to next integer) if controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_MRD",
  {
	pos: 12,
	width: 6,
	type: "rw",
	default: 4,
	help: "tMRD- Indicates the number of cycles to wait after a mode register write or read. Depending on the connected SDRAM, tMRD represents:  - DDR2/mDDR: Time from MRS to any command  - DDR3/4: Time from MRS to MRS command  - LPDDR2: not used  - LPDDR3/4: Time from MRS to non-MRS command  When the controller is operating in 1:2 frequency ratio mode, program this to (tMRD/2) and round it up to the next integer value. If C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead. If CAL mode is enabled (DFITMG1.dfi_t_cmd_lat &gt; 0), tCAL (=DFITMG1.dfi_cmd_lat) must be added to the previous calculations. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg4", {
  help: "SDRAM Timing Register 4",
  fields: new Map([
 ["T_RP",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 5,
	help: "tRP: Indicates the minimum time from single-bank precharge to activate of same bank. When the controller is operating in 1:1 frequency ratio mode, t_rp must be set to RoundUp(tRP/tCK). When the controller is operating in 1:2 frequency ratio mode, t_rp must be set to RoundDown(RoundUp(tRP/tCK)/2) + 1. When the controller is operating in 1:2 frequency ratio mode in LPDDR4, t_rp must be set to RoundUp(RoundUp(tRP/tCK)/2). Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_RRD",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 4,
	help: "DDR4: tRRD_L: This is the minimum time between activates from bank \"a\" to bank \"b\" for same bank group. Others: tRRD: Minimum time between activates from bank \"a\" to bank \"b\" When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_L/2 or tRRD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_CCD",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 4,
	help: "DDR4: tCCD_L: This is the minimum time between two reads or two writes for same bank group. Others: tCCD: This is the minimum time between two reads or two writes. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_L/2 or tCCD/2) and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_RCD",
  {
	pos: 24,
	width: 5,
	type: "rw",
	default: 5,
	help: "tRCD - tAL: Indicates the minimum time from activate to read or write command to same bank. When the controller is operating in 1:2 frequency ratio mode, program this to ((tRCD - tAL)/2) and round it up to the next integer value.  Minimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2 when the controller is operating in 1:2 frequency ratio mode. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg5", {
  help: "SDRAM Timing Register 5",
  fields: new Map([
 ["T_CKE",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 3,
	help: "Indicates the minimum number of cycles of CKE HIGH/LOW during power-down and self-refresh.  - LPDDR2/LPDDR3 mode - Set this to the larger of tCKE or tCKESR  - LPDDR4 mode - Set this to the larger of tCKE or tSR  - Non-LPDDR2/non-LPDDR3/non-LPDDR4 designs - Set this to tCKE value When the controller is operating in 1:2 frequency ratio mode, program this to (value described above)/2 and round it up to the next integer value. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_CKESR",
  {
	pos: 8,
	width: 8,
	type: "rw",
	default: 4,
	help: "Indicates the minimum CKE low width for self-refresh or self-refresh power down entry to exit timing in memory clock cycles.  Recommended settings:  - mDDR - tRFC  - LPDDR2 - tCKESR  - LPDDR3 - tCKESR  - LPDDR4 - max(tCKE, tSR)  - DDR2 - tCKE   - DDR3 - tCKE + 1   - DDR4(No RDIMM) - tCKE + 1 (+ PL(parity latency)(*))  - DDR4(RDIMM)    - t_cksre + tCKEV (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_CKSRE",
  {
	pos: 16,
	width: 8,
	type: "rw",
	default: 5,
	help: "This is the time after self-refresh Down Entry that CK is maintained as a valid clock. Specifies the clock disable delay after SRE.  Recommended settings:  - mDDR - 0  - LPDDR2 - 2  - LPDDR3 - 2  - LPDDR4 - tCKELCK  - DDR2 - 1   - DDR3 - Max (10 ns, 5 tCK)  - DDR4(No RDIMM) - Max (10 ns, 5 tCK) (+ PL(parity latency)(*))  - DDR4(RDIMM)    - Max (Max (10 ns, 5 tCK) (+ PL(parity latency)(*)), tCKOff) (*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register must be increased by PL. When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_CKSRX",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 5,
	help: "This is the time before self-refresh Exit that CK is maintained as a valid clock before issuing SRX. Specifies the clock stable time before SRX.  Recommended settings:  - mDDR - 1  - LPDDR2 - 2  - LPDDR3 - 2  - LPDDR4 - tCKCKEH  - DDR2 - 1   - DDR3 - tCKSRX   - DDR4 - tCKSRX  When the controller is operating in 1:2 frequency ratio mode, program this to recommended value divided by two and round it up to next integer. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg8", {
  help: "SDRAM Timing Register 8",
  fields: new Map([
 ["T_XS_X32",
  {
	pos: 0,
	width: 7,
	type: "rw",
	default: 5,
	help: "tXS: Exit self-refresh to commands not requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_XS_DLL_X32",
  {
	pos: 8,
	width: 7,
	type: "rw",
	default: 68,
	help: "tXSDLL: Exit self-refresh to commands requiring a locked DLL. When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: Used only for DDR2, DDR3 and DDR4 SDRAMs. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_XS_ABORT_X32",
  {
	pos: 16,
	width: 7,
	type: "rw",
	default: 3,
	help: "tXS_ABORT: Exit self-refresh to commands not requiring a locked DLL in self-refresh Abort. When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: Ensure this is less than or equal to t_xs_x32. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_XS_FAST_X32",
  {
	pos: 24,
	width: 7,
	type: "rw",
	default: 3,
	help: "tXS_FAST: Exit self-refresh to ZQCL, ZQCS and MRS (only CL, WR, RTP and Geardown mode). When the controller is operating in 1:2 frequency ratio mode, program this to the previous value divided by 2 and round up to next integer value. Note: This is applicable to only ZQCL/ZQCS commands.  Note: Ensure this is less than or equal to t_xs_x32. Unit: Multiples of 32 DFI clock cycles. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["dramtmg9", {
  help: "SDRAM Timing Register 9",
  fields: new Map([
 ["WR2RD_S",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 13,
	help: "Minimum time from write command to read command for different bank group.  This must include time for bus turn-around and all PHY and system requirements.  After the PHY has completed training, the value programmed may need to be increased.  Please see the relevant PHY databook for details of what should be included here.  The following calculations are minimum values, and do not include the PHY/system requirements mentioned above:  CWL + BL/2 + tWTR_S  Where:  - CWL: CAS write latency  - BL: Burst length. This must match the value programmed in the BL bit of the mode register to the SDRAM  - tWTR_S: Internal write to read command delay for different bank group. This comes directly from the SDRAM specification WTR_S must be increased by one if DDR4 2tCK write preamble is used. When the controller is operating in 1:2 mode, divide the value calculated using the previous equation by 2, and round it up to next integer.  If your configuration has RANKCTL1.wr2rd_dr, write to read bus turn-around between different physical ranks are controlled by RANKCTL1.wr2rd_dr.   Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 2, Group 4",
  }],
 ["T_RRD_S",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 4,
	help: "tRRD_S: This is the minimum time between activates from bank \"a\" to bank \"b\" for different bank group. When the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_S/2) and round it up to the next integer value. Present only in designs configured to support DDR4. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["T_CCD_S",
  {
	pos: 16,
	width: 3,
	type: "rw",
	default: 4,
	help: "tCCD_S: This is the minimum time between two reads or two writes for different bank group. For bank switching (from bank \"a\" to bank \"b\"), the minimum time is this value + 1. When the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_S/2) and round it up to the next integer value. Present only in designs configured to support DDR4. Unit: DFI clock cycles. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
 ["DDR4_WR_PREAMBLE",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 0,
	help: "DDR4 Write preamble mode.    Present only with MEMC_FREQ_RATIO=2. Programming Mode: Quasi-dynamic Group 2, Group 4",
  }],
  ])} ],
 ["odtcfg", {
  help: "ODT Configuration Register",
  fields: new Map([
 ["RD_ODT_DELAY",
  {
	pos: 2,
	width: 5,
	type: "rw",
	default: 0,
	help: "Indicates the delay, in DFI PHY clock cycles, from issuing a read command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2. Recommended values: DDR2:  - CL + AL - 4 (not DDR2-1066), CL + AL - 5 (DDR2-1066)    If (CL + AL - 4 &lt; 0), uMCTL2 does not support ODT for read operation. DDR3:  - CL - CWL DDR4:  - CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)    WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble) RD_PREAMBLE = 1 (1tCK read preamble), 2 (2tCK read preamble) If (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) &lt; 0, uMCTL2 does not support ODT for read operation. LPDDR3:  - RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["RD_ODT_HOLD",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 4,
	help: "DFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2. Recommended values: DDR2:  - BL8 - 0x6 (not DDR2-1066), 0x7 (DDR2-1066)  - BL4 - 0x4 (not DDR2-1066), 0x5 (DDR2-1066) DDR3:  - BL8 - 0x6 DDR4:  - BL8 - 5 + RD_PREAMBLE    RD_PREAMBLE = 1 (1tCK read preamble), 2 (2tCK read preamble) LPDDR3:  - BL8 - 5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["WR_ODT_DELAY",
  {
	pos: 16,
	width: 5,
	type: "rw",
	default: 0,
	help: "Indicates the delay, in DFI PHY clock cycles, from issuing a write command to setting ODT values associated with that command. ODT setting must remain constant for the entire time that DQS is driven by the uMCTL2. Recommended values: DDR2:  - CWL + AL - 3 (DDR2-400/533/667), CWL + AL - 4 (DDR2-800), CWL + AL - 5 (DDR2-1066)    If (CWL + AL - 3  &lt; 0), uMCTL2 does not support ODT for write operation.  DDR3:  - 0x0  DDR4:  - DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)   LPDDR3:  - WL - 1 - RU(tODTon(max)/tCK)) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
 ["WR_ODT_HOLD",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 4,
	help: "DFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2. Recommended values: DDR2:  - BL8 - 0x5 (DDR2-400/533/667), 0x6 (DDR2-800), 0x7 (DDR2-1066)  - BL4 - 0x3 (DDR2-400/533/667), 0x4 (DDR2-800), 0x5 (DDR2-1066) DDR3:  - BL8 - 0x6 DDR4:   - BL8 - 5 + WR_PREAMBLE + CRC_MODE    WR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble)    CRC_MODE = 0 (not CRC mode), 1 (CRC mode) LPDDR3:  - BL8 - 7 + RU(tODTon(max)/tCK) Unit: DFI PHY clock cycles. Programming Mode: Quasi-dynamic Group 1, Group 4",
  }],
  ])} ],
 ["rfshtmg", {
  help: "Refresh Timing Register",
  fields: new Map([
 ["T_RFC_MIN",
  {
	pos: 0,
	width: 10,
	type: "rw",
	default: 140,
	help: "tRFC (min): Minimum time from refresh to refresh or activate. When the controller is operating in 1:1 mode, t_rfc_min must be set to RoundUp(tRFCmin/tCK). When the controller is operating in 1:2 mode, t_rfc_min must be set to RoundUp(RoundUp(tRFCmin/tCK)/2). In LPDDR2/LPDDR3/LPDDR4 mode:  - If using all-bank refreshes, the tRFCmin value in the previous equations is equal to tRFCab  - If using per-bank refreshes, the tRFCmin value in the previous equations is equal to tRFCpb In DDR4 mode, the tRFCmin value in the previous equations is different depending on the refresh mode (fixed 1X,2X,4X) and the device density. You must program the appropriate value from the spec based on the 'refresh_mode' and the device density that is used. Unit: DFI clock cycles. Programming Mode: Dynamic - Refresh Related",
  }],
 ["T_RFC_NOM_X1_X32",
  {
	pos: 16,
	width: 12,
	type: "rw",
	default: 98,
	help: "Average time interval between refreshes per rank (Specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR, LPDDR2, LPDDR3 and LPDDR4). When the controller is operating in 1:1 mode, set this register to RoundDown(tREFI/tCK) When the controller is operating in 1:2 mode, set this register to RoundDown(RoundDown(tREFI/tCK)/2) In both the previous cases, if RFSHTMG.t_rfc_nom_x1_sel = 0, divide the previous result by 32 and round down. For LPDDR2/LPDDR3/LPDDR4:  - If using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), use tREFIab in the previous calculations  - If using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), use tREFIpb in the previous calculations For DDR4 mode, tREFI value is different depending on the refresh mode. You must program appropriate value from the spec based on the value programmed in the refresh mode register. Note:  - RFSHTMG.t_rfc_nom_x1_x32 must be greater than 0x1  - If RFSHTMG.t_rfc_nom_x1_sel == 1, RFSHTMG.t_rfc_nom_x1_x32 must be greater than RFSHTMG.t_rfc_min  - If RFSHTMG.t_rfc_nom_x1_sel == 0, RFSHTMG.t_rfc_nom_x1_x32 * 32 must be greater than RFSHTMG.t_rfc_min  - In non-DDR4 or DDR4 Fixed 1x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0xFFE  - In DDR4 Fixed 2x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x7FF  - In DDR4 Fixed 4x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x3FF Unit: DFI clock cycles or multiples of 32 DFI clock cycles, depending on RFSHTMG.t_rfc_nom_x1_sel. For more information on how to program this register field, see \"Note 1\" in the \"Notes on Timing Registers\" section. Programming Mode: Dynamic - Refresh Related",
  }],
  ])} ],
 ["addrmap0", {
  help: "Address Map Register 0",
  fields: new Map([
 ["ADDRMAP_CS_BIT0",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as rank address bit 0. Valid Range: 0 to 29, and 31 Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then rank address bit 0 is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap1", {
  help: "Address Map Register 1",
  fields: new Map([
 ["ADDRMAP_BANK_B0",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as bank address bit 0. Valid Range: 0 to 32, and 63 Internal Base: 2 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 0 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_BANK_B1",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as bank address bit 1. Valid Range: 0 to 32, and 63 Internal Base: 3 The selected HIF address bit for each of the bank address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 1 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_BANK_B2",
  {
	pos: 16,
	width: 6,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as bank address bit 2. Valid Range: 0 to 31, and 63 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank address bit 2 is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap2", {
  help: "Address Map Register 2",
  fields: new Map([
 ["ADDRMAP_COL_B2",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 2  - Half bus width mode - Selects the HIF address bit used as column address bit 3  - Quarter bus width mode - Selects the HIF address bit used as column address bit 4 Valid Range: 0 to 7 Internal Base: 2 The selected HIF address bit is determined by adding the internal base to the value of this field.  Note, if UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=8, it is required to program this to 0 unless:  - In Half or Quarter bus width (MSTR.data_bus_width!=00) and  - PCCFG.bl_exp_mode==1 and either  - In DDR4 and ADDRMAP8.addrmap_bg_b0==0 or  - In LPDDR4 and ADDRMAP1.addrmap_bank_b0==0 If UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=16, it is required to program this to 0 unless:  - In Half or Quarter bus width (MSTR.data_bus_width!=00) and   - PCCFG.bl_exp_mode==1 and  - In DDR4 and ADDRMAP8.addrmap_bg_b0==0 Otherwise, if MEMC_BURST_LENGTH=8 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2.  If MEMC_BURST_LENGTH=16 and Full Bus Width (MSTR.data_bus_width==00), it is recommended to program this to 0 so that HIF[2] maps to column address bit 2. If MEMC_BURST_LENGTH=16 and Half Bus Width (MSTR.data_bus_width==01), it is recommended to program this to 0 so that HIF[2] maps to column address bit 3.  Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B3",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 3  - Half bus width mode - Selects the HIF address bit used as column address bit 4  - Quarter bus width mode - Selects the HIF address bit used as column address bit 5 Valid Range: 0 to 7, x. x indicates a valid value in the inline ECC configuration.  Internal Base: 3 The selected HIF address bit is determined by adding the internal base to the value of this field. Note, if UMCTL2_INCL_ARB=1, MEMC_BURST_LENGTH=16, Full bus width (MSTR.data_bus_width=00) and BL16 (MSTR.burst_rdwr=1000), it is recommended to program this to 0.  In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), if MEMC_BURST_LENGTH is 16, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 3 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2) Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B4",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 4  - Half bus width mode - Selects the HIF address bit used as column address bit 5  - Quarter bus width mode - Selects the HIF address bit used as column address bit 6 Valid Range: 0 to 7, and 15 Internal Base: 4 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B5",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 5  - Half bus width mode - Selects the HIF address bit used as column address bit 6  - Quarter bus width mode - Selects the HIF address bit used as column address bit 7  Valid Range: 0 to 7, and 15 Internal Base: 5 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then this column address bit is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap3", {
  help: "Address Map Register 3",
  fields: new Map([
 ["ADDRMAP_COL_B6",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 6.  - Half bus width mode - Selects the HIF address bit used as column address bit 7.  - Quarter bus width mode - Selects the HIF address bit used as column address bit 8. Valid Range: 0 to 7, x and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 6 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 31 and then this column address bit is set to 0. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), if MEMC_BURST_LENGTH is 8, number of column address is 10 and work on half bus width mode, column bit 8, column bit 7 and column bit 6 must map to the highest 3 valid HIF address bits. This register need be set to x. (x = the highest valid HIF address bit - internal base - 2) Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B7",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 7  - Half bus width mode - Selects the HIF address bit used as column address bit 8  - Quarter bus width mode - Selects the HIF address bit used as column address bit 9 Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 7  The selected HIF address bit is determined by adding the internal base to the value of this field.  In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 7 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B8",
  {
	pos: 16,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 8  - Half bus width mode - Selects the HIF address bit used as column address bit 9  - Quarter bus width mode - Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode) Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 8 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 8 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 8 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B9",
  {
	pos: 24,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 9  - Half bus width mode - Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode)  - Quarter bus width mode - Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode) Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 9 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 9 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 9 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 9 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap4", {
  help: "Address Map Register 4",
  fields: new Map([
 ["ADDRMAP_COL_B10",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in LPDDR2/LPDDR3 mode)  - Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode)  - Quarter bus width mode: UNUSED. See later in this description for value you need to set to make it unused Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 10 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 10 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 10 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 10 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_COL_B11",
  {
	pos: 8,
	width: 5,
	type: "rw",
	default: 0,
	help: "  - Full bus width mode - Selects the HIF address bit used as column address bit 13 (11 in LPDDR2/LPDDR3 mode)  - Half bus width mode - UNUSED. See later in this description for value you need to set to make it unused  - Quarter bus width mode - UNUSED. See later in this description for value you need to set to make it unused Valid Range: 0 to 7, x, and 31. x indicates a valid value in the inline ECC configuration. Internal Base: 11 The selected HIF address bit is determined by adding the internal base to the value of this field. Note: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating auto-precharge, and hence no source address bit can be mapped to column address bit 10. In LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence column bit 10 is used. In Inline ECC configuration (MEMC_INLINE_ECC=1) and Inline ECC mode is enabled (ECCCFG0.ecc_mode=4), the highest 3 column address bits must map to the highest 3 valid HIF address bits. If column bit 11 is the highest column address bit, it must map to the highest valid HIF address bit. (x = the highest valid HIF address bit - internal base) If column bit 11 is the second highest column address bit, it must map to the second highest valid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base) If column bit 11 is the third highest column address bit, it must map to the third highest valid HIF address bit. (x = the highest valid HIF address bit - 2 - internal base) If unused, set to 31 and then this column address bit is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap5", {
  help: "Address Map Register 5",
  fields: new Map([
 ["ADDRMAP_ROW_B0",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as row address bit 0. Valid Range: 0 to 11 Internal Base: 6 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B1",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as row address bit 1. Valid Range: 0 to 11 Internal Base: 7 The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B2_10",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as row address bits 2 to 10. Valid Range: 0 to 11, and 15 Internal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) and so on, increasing to 16 (for row address bit 10) The selected HIF address bit for each of the row address bits is determined by adding the internal base to the value of this field. When set to 15, the values of row address bits 2 to 10 are defined by registers ADDRMAP9, ADDRMAP10, ADDRMAP11. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B11",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 11. Valid Range: 0 to 11, and 15 Internal Base: 17 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 11 is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap6", {
  help: "Address Map Register 6",
  fields: new Map([
 ["ADDRMAP_ROW_B12",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 12. Valid Range: 0 to 11, and 15 Internal Base: 18 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 12 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B13",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 13. Valid Range: 0 to 11, and 15 Internal Base: 19 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 13 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B14",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 14. Valid Range: 0 to 11, and 15 Internal Base: 20 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 14 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B15",
  {
	pos: 24,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 15. Valid Range: 0 to 11, and 15 Internal Base: 21 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 15 is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap7", {
  help: "Address Map Register 7",
  fields: new Map([
 ["ADDRMAP_ROW_B16",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 16. Valid Range: 0 to 11, and 15 Internal Base: 22 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 16 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_ROW_B17",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bit used as row address bit 17. Valid Range: 0 to 11, and 15 Internal Base: 23 The selected HIF address bit is determined by adding the internal base to the value of this field. If unused, set to 15 and then row address bit 17 is set to 0 for DDR4 or set to 1 for LPDDR4 backward compability. Programming Mode: Static",
  }],
  ])} ],
 ["addrmap8", {
  help: "Address Map Register 8",
  fields: new Map([
 ["ADDRMAP_BG_B0",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as bank group address bit 0. Valid Range: 0 to 32, and 63 Internal Base: 2 The selected HIF address bit for each of the bank group address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank group address bit 0 is set to 0. Programming Mode: Static",
  }],
 ["ADDRMAP_BG_B1",
  {
	pos: 8,
	width: 6,
	type: "rw",
	default: 0,
	help: "Selects the HIF address bits used as bank group address bit 1. Valid Range: 0 to 32, and 63 Internal Base: 3 The selected HIF address bit for each of the bank group address bits is determined by adding the internal base to the value of this field. If unused, set to 63 and then bank group address bit 1 is set to 0. Programming Mode: Static",
  }],
  ])} ],
 ["dcr", {
  help: "DRAM Configuration Register",
  fields: new Map([
 ["DDRMD",
  {
	pos: 0,
	width: 3,
	type: "rw",
	default: 3,
	help: "DDR Mode.",
  }],
 ["DDR8BNK",
  {
	pos: 3,
	width: 1,
	type: "rw",
	default: 1,
	help: "DDR 8-Bank.",
  }],
 ["PDQ",
  {
	pos: 4,
	width: 3,
	type: "rw",
	default: 0,
	help: "Primary DQ.",
  }],
 ["MPRDQ",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 0,
	help: "Multi-Purpose Register (MPR) DQ.",
  }],
 ["DDRTYPE",
  {
	pos: 8,
	width: 2,
	type: "rw",
	default: 0,
	help: "DDR Type.",
  }],
 ["BYTEMASK",
  {
	pos: 10,
	width: 8,
	type: "rw",
	default: 1,
	help: "Byte Mask.",
  }],
 ["RESERVED_26_18",
  {
	pos: 18,
	width: 9,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["NOSRA",
  {
	pos: 27,
	width: 1,
	type: "rw",
	default: 0,
	help: "No Simultaneous Rank Access.",
  }],
 ["DDR2T",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "DDR 2T Timing.",
  }],
 ["UDIMM",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Un-buffered DIMM Address Mirroring.",
  }],
 ["UBG",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 0,
	help: "Un-used Bank Group.",
  }],
 ["RESERVED_31",
  {
	pos: 31,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["dsgcr", {
  help: "DDR System General Configuration Register",
  fields: new Map([
 ["PUREN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 1,
	help: "PHY Update Request Enable.",
  }],
 ["BDISEN",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 1,
	help: "Byte Disable Enable.",
  }],
 ["CTLZUEN",
  {
	pos: 2,
	width: 1,
	type: "rw",
	default: 0,
	help: "Controller Impedance Update Enable.",
  }],
 ["LPIOPD",
  {
	pos: 3,
	width: 1,
	type: "rw",
	default: 1,
	help: "Low Power I/O Power Down.",
  }],
 ["LPPLLPD",
  {
	pos: 4,
	width: 1,
	type: "rw",
	default: 1,
	help: "Low Power PLL Power Down.",
  }],
 ["CUAEN",
  {
	pos: 5,
	width: 1,
	type: "rw",
	default: 0,
	help: "Controller Update Acknowledge Enable.",
  }],
 ["DQSGX",
  {
	pos: 6,
	width: 2,
	type: "rw",
	default: 0,
	help: "DQS Gate Extension.",
  }],
 ["PUAD",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 0,
	help: "PHY Update Acknowledge Delay.",
  }],
 ["DTOODT",
  {
	pos: 12,
	width: 1,
	type: "rw",
	default: 0,
	help: "DTO On-Die Termination.",
  }],
 ["RESERVED_13",
  {
	pos: 13,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["DTOPDR",
  {
	pos: 14,
	width: 1,
	type: "rw",
	default: 1,
	help: "DTO Power Down Receiver.",
  }],
 ["DTOIOM",
  {
	pos: 15,
	width: 1,
	type: "rw",
	default: 0,
	help: "DTO I/O Mode.",
  }],
 ["DTOOE",
  {
	pos: 16,
	width: 1,
	type: "rw",
	default: 0,
	help: "DTO Output Enable.",
  }],
 ["ATOAE",
  {
	pos: 17,
	width: 1,
	type: "rw",
	default: 0,
	help: "ATO Analog Test Enable.",
  }],
 ["WRRMODE",
  {
	pos: 18,
	width: 1,
	type: "rw",
	default: 1,
	help: "Write Path Rise-to-Rise Mode.",
  }],
 ["SDRMODE",
  {
	pos: 19,
	width: 2,
	type: "rw",
	default: 0,
	help: "Single Data Rate Mode.",
  }],
 ["RSTOE",
  {
	pos: 21,
	width: 1,
	type: "rw",
	default: 1,
	help: "SDRAM Reset Output Enable.",
  }],
 ["RRRMODE",
  {
	pos: 22,
	width: 1,
	type: "rw",
	default: 1,
	help: "Read Path Rise-to-Rise Mode.",
  }],
 ["PHYZUEN",
  {
	pos: 23,
	width: 1,
	type: "rw",
	default: 0,
	help: "PHY Impedance Update Enable.",
  }],
 ["LPACIOPD",
  {
	pos: 24,
	width: 1,
	type: "rw",
	default: 0,
	help: "Low Power AC I/O Power Down.",
  }],
 ["RESERVED_31_25",
  {
	pos: 25,
	width: 7,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["dtcr0", {
  help: "Data Training Configuration Register 0",
  fields: new Map([
 ["DTRPTN",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 7,
	help: "Data Training Repeat Number.",
  }],
 ["RESERVED_5_4",
  {
	pos: 4,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["DTMPR",
  {
	pos: 6,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training Using MPR.",
  }],
 ["DTCMPD",
  {
	pos: 7,
	width: 1,
	type: "rw",
	default: 1,
	help: "Data Training Compare Data.",
  }],
 ["RESERVED_10_8",
  {
	pos: 8,
	width: 3,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["DTDBS4",
  {
	pos: 11,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training Debug Byte Select Most Significant Bit.",
  }],
 ["DTWBDDM",
  {
	pos: 12,
	width: 1,
	type: "rw",
	default: 1,
	help: "Data Training Write Bit Deskew Data Mask.",
  }],
 ["DTBDC",
  {
	pos: 13,
	width: 1,
	type: "rw",
	default: 1,
	help: "Data Training Bit Deskew Centering.",
  }],
 ["DTRDBITR",
  {
	pos: 14,
	width: 2,
	type: "rw",
	default: 2,
	help: "Data Training read DBI deskewing configuration.",
  }],
 ["DTDBS",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 0,
	help: "Data Training Debug Byte Select.",
  }],
 ["DTDEN",
  {
	pos: 20,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training Debug Enable.",
  }],
 ["DTDSTP",
  {
	pos: 21,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training Debug Step.",
  }],
 ["DTEXD",
  {
	pos: 22,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data Training Extended Write DQS.",
  }],
 ["RESERVED_23",
  {
	pos: 23,
	width: 1,
	type: "rw",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["DTDRS",
  {
	pos: 24,
	width: 2,
	type: "rw",
	default: 0,
	help: "Data Training Debug Rank Select.",
  }],
 ["RESERVED_27_26",
  {
	pos: 26,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["RFSHDT",
  {
	pos: 28,
	width: 4,
	type: "rw",
	default: 8,
	help: "Refresh During Training and BIST.",
  }],
  ])} ],
 ["dtcr1", {
  help: "Data Training Configuration Register 1",
  fields: new Map([
 ["BSTEN",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 1,
	help: "Basic Gate Training Enable.",
  }],
 ["RDLVLEN",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 1,
	help: "Read Leveling Enable.",
  }],
 ["RDPRMBL_TRN",
  {
	pos: 2,
	width: 1,
	type: "rw",
	default: 1,
	help: "Read Preamble Training Enable.",
  }],
 ["RESERVED_3",
  {
	pos: 3,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["RDLVLGS",
  {
	pos: 4,
	width: 3,
	type: "rw",
	default: 3,
	help: "Read Leveling Gate Shift.",
  }],
 ["RESERVED_7",
  {
	pos: 7,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["RDLVLGDIFF",
  {
	pos: 8,
	width: 3,
	type: "rw",
	default: 2,
	help: "Read Leveling Gate Sampling Difference.",
  }],
 ["WLVLDPRD",
  {
	pos: 11,
	width: 1,
	type: "rw",
	default: 1,
	help: "Write Leveling Validation Period.",
  }],
 ["DTRANK",
  {
	pos: 12,
	width: 2,
	type: "rw",
	default: 0,
	help: "Data Training Rank.",
  }],
 ["RESERVED_15_14",
  {
	pos: 14,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["RANKEN",
  {
	pos: 16,
	width: 2,
	type: "rw",
	default: 3,
	help: "Rank Enable.",
  }],
 ["RANKEN_RSVD",
  {
	pos: 18,
	width: 14,
	type: "ro",
	default: 0,
	help: "Rank Enable Reserved",
  }],
  ])} ],
 ["dxccr", {
  help: "DATX8 Common Configuration Register",
  fields: new Map([
 ["DXODT",
  {
	pos: 0,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data On-Die Termination.",
  }],
 ["DXIOM",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "Data I/O Mode.",
  }],
 ["MDLEN",
  {
	pos: 2,
	width: 1,
	type: "rw",
	default: 1,
	help: "Master Delay Line Enable.",
  }],
 ["DQSGLB",
  {
	pos: 3,
	width: 2,
	type: "rw",
	default: 0,
	help: "Read DQS Gate I/O Loopback.",
  }],
 ["DQSRES",
  {
	pos: 5,
	width: 4,
	type: "rw",
	default: 4,
	help: "DQS Resistor.",
  }],
 ["DQSNRES",
  {
	pos: 9,
	width: 4,
	type: "rw",
	default: 12,
	help: "DQS# Resistor.",
  }],
 ["DXSR",
  {
	pos: 13,
	width: 2,
	type: "rw",
	default: 0,
	help: "Data Slew Rate.",
  }],
 ["MSBUDQ",
  {
	pos: 15,
	width: 3,
	type: "rw",
	default: 0,
	help: "Most Significant Byte Unused DQs.",
  }],
 ["RESERVED_19_18",
  {
	pos: 18,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["QSCNTENCTL",
  {
	pos: 20,
	width: 1,
	type: "rw",
	default: 0,
	help: "QS Counter Enable Control.",
  }],
 ["UDQIOM",
  {
	pos: 21,
	width: 1,
	type: "rw",
	default: 0,
	help: "Unused DQ I/O Mode.",
  }],
 ["QSCNTEN",
  {
	pos: 22,
	width: 1,
	type: "rw",
	default: 1,
	help: "QS Counter Enable.",
  }],
 ["DXDCCBYP",
  {
	pos: 23,
	width: 1,
	type: "rw",
	default: 1,
	help: "DATX8 Duty Cycle Correction Bypass.",
  }],
 ["RESERVED_28_24",
  {
	pos: 24,
	width: 5,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["RKLOOP",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 1,
	help: "Rank looping (per-rank eye centering) enable.",
  }],
 ["X4DQSMD",
  {
	pos: 30,
	width: 1,
	type: "ro",
	default: 0,
	help: "X4 DQS Mode.",
  }],
 ["X4MODE",
  {
	pos: 31,
	width: 1,
	type: "ro",
	default: 0,
	help: "X4 SDRAM Mode.",
  }],
  ])} ],
 ["pgcr2", {
  help: "PHY General Configuration Register 2",
  fields: new Map([
 ["TREFPRD",
  {
	pos: 0,
	width: 18,
	type: "rw",
	default: 74880,
	help: "Refresh Period.",
  }],
 ["CSNCIDMUX",
  {
	pos: 18,
	width: 1,
	type: "rw",
	default: 0,
	help: "CSN and CID Multiplexing.",
  }],
 ["FXDLAT",
  {
	pos: 19,
	width: 1,
	type: "rw",
	default: 0,
	help: "Fixed Latency.",
  }],
 ["DTPMXTMR",
  {
	pos: 20,
	width: 8,
	type: "ro",
	default: 0,
	help: "Data Training PUB Mode Exit Timer.",
  }],
 ["FXDLATINCR",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "Fixed Latency Programmable Increment.",
  }],
 ["RFSHMODE",
  {
	pos: 29,
	width: 2,
	type: "rw",
	default: 0,
	help: "Refresh Mode.",
  }],
 ["RESERVED_31",
  {
	pos: 31,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["schcr1", {
  help: "Scheduler Command Register 1",
  fields: new Map([
 ["RESERVED_1_0",
  {
	pos: 0,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["ALLRANK",
  {
	pos: 2,
	width: 1,
	type: "rw",
	default: 0,
	help: "All Ranks Enabled.",
  }],
 ["RESERVED_3",
  {
	pos: 3,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["SCBK",
  {
	pos: 4,
	width: 2,
	type: "rw",
	default: 0,
	help: "Scheduler Command Bank Address.",
  }],
 ["SCBG",
  {
	pos: 6,
	width: 2,
	type: "rw",
	default: 0,
	help: "Scheduler Command Bank Group.",
  }],
 ["SCADDR",
  {
	pos: 8,
	width: 20,
	type: "rw",
	default: 0,
	help: "Scheduler Command Address.",
  }],
 ["SCRNK",
  {
	pos: 28,
	width: 4,
	type: "rw",
	default: 0,
	help: "Scheduler Rank Address.",
  }],
  ])} ],
 ["zq0pr", {
  help: "ZQ n Impedance Control Program Register",
  fields: new Map([
 ["RESERVED_7_0",
  {
	pos: 0,
	width: 8,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["ZPROG_ASYM_DRV_PU",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 11,
	help: "Asymmetric Drive Pull-up Impedance Divide Ratio.",
  }],
 ["ZPROG_ASYM_DRV_PD",
  {
	pos: 12,
	width: 4,
	type: "rw",
	default: 11,
	help: "Asymmetric Drive Pull-down Impedance Divide Ratio.",
  }],
 ["ZPROG_PU_ODT_ONLY",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 7,
	help: "ODT Pull-up Impedance Divide Ratio.",
  }],
 ["PU_DRV_ADJUST",
  {
	pos: 20,
	width: 2,
	type: "rw",
	default: 0,
	help: "Pull-up Drive Strength Adjustment.",
  }],
 ["PD_DRV_ADJUST",
  {
	pos: 22,
	width: 2,
	type: "rw",
	default: 0,
	help: "Pull-down Drive Strength Adjustment.",
  }],
 ["RESERVED_27_24",
  {
	pos: 24,
	width: 4,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["PU_ODT_ONLY",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "Pull-up ODT Only Enable.",
  }],
 ["ZSEGBYP",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Impedance Calibration Segment Bypass.",
  }],
 ["ODT_ZDEN",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 0,
	help: "On-Die Termination Over-ride Enable.",
  }],
 ["DRV_ZDEN",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 0,
	help: "Output Impedance Over-Ride Enable.",
  }],
  ])} ],
 ["zq1pr", {
  help: "ZQ n Impedance Control Program Register",
  fields: new Map([
 ["RESERVED_7_0",
  {
	pos: 0,
	width: 8,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["ZPROG_ASYM_DRV_PU",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 11,
	help: "Asymmetric Drive Pull-up Impedance Divide Ratio.",
  }],
 ["ZPROG_ASYM_DRV_PD",
  {
	pos: 12,
	width: 4,
	type: "rw",
	default: 11,
	help: "Asymmetric Drive Pull-down Impedance Divide Ratio.",
  }],
 ["ZPROG_PU_ODT_ONLY",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 7,
	help: "ODT Pull-up Impedance Divide Ratio.",
  }],
 ["PU_DRV_ADJUST",
  {
	pos: 20,
	width: 2,
	type: "rw",
	default: 0,
	help: "Pull-up Drive Strength Adjustment.",
  }],
 ["PD_DRV_ADJUST",
  {
	pos: 22,
	width: 2,
	type: "rw",
	default: 0,
	help: "Pull-down Drive Strength Adjustment.",
  }],
 ["RESERVED_27_24",
  {
	pos: 24,
	width: 4,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["PU_ODT_ONLY",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "Pull-up ODT Only Enable.",
  }],
 ["ZSEGBYP",
  {
	pos: 29,
	width: 1,
	type: "rw",
	default: 0,
	help: "Impedance Calibration Segment Bypass.",
  }],
 ["ODT_ZDEN",
  {
	pos: 30,
	width: 1,
	type: "rw",
	default: 0,
	help: "On-Die Termination Over-ride Enable.",
  }],
 ["DRV_ZDEN",
  {
	pos: 31,
	width: 1,
	type: "rw",
	default: 0,
	help: "Output Impedance Over-Ride Enable.",
  }],
  ])} ],
 ["zq2pr", {
  help: "ZQ n Impedance Control Program Register",
  fields: new Map([
 ["RESERVED_7_0",
  {
	pos: 0,
	width: 8,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["ZPROG_ASYM_DRV_PU",
  {
	pos: 8,
	width: 4,
	type: "ro",
	default: 0,
	help: "Asymmetric Drive Pull-up Impedance Divide Ratio.",
  }],
 ["ZPROG_ASYM_DRV_PD",
  {
	pos: 12,
	width: 4,
	type: "ro",
	default: 0,
	help: "Asymmetric Drive Pull-down Impedance Divide Ratio.",
  }],
 ["ZPROG_PU_ODT_ONLY",
  {
	pos: 16,
	width: 4,
	type: "ro",
	default: 0,
	help: "ODT Pull-up Impedance Divide Ratio.",
  }],
 ["PU_DRV_ADJUST",
  {
	pos: 20,
	width: 2,
	type: "ro",
	default: 0,
	help: "Pull-up Drive Strength Adjustment.",
  }],
 ["PD_DRV_ADJUST",
  {
	pos: 22,
	width: 2,
	type: "ro",
	default: 0,
	help: "Pull-down Drive Strength Adjustment.",
  }],
 ["RESERVED_27_24",
  {
	pos: 24,
	width: 4,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["PU_ODT_ONLY",
  {
	pos: 28,
	width: 1,
	type: "ro",
	default: 0,
	help: "Pull-up ODT Only Enable.",
  }],
 ["ZSEGBYP",
  {
	pos: 29,
	width: 1,
	type: "ro",
	default: 0,
	help: "Impedance Calibration Segment Bypass.",
  }],
 ["ODT_ZDEN",
  {
	pos: 30,
	width: 1,
	type: "ro",
	default: 0,
	help: "On-Die Termination Over-ride Enable.",
  }],
 ["DRV_ZDEN",
  {
	pos: 31,
	width: 1,
	type: "ro",
	default: 0,
	help: "Output Impedance Over-Ride Enable.",
  }],
  ])} ],
 ["zqcr", {
  help: "ZQ Impedance Control Register",
  fields: new Map([
 ["RESERVED_0",
  {
	pos: 0,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TERM_OFF",
  {
	pos: 1,
	width: 1,
	type: "rw",
	default: 0,
	help: "Termination OFF.",
  }],
 ["ZQPD",
  {
	pos: 2,
	width: 1,
	type: "rw",
	default: 0,
	help: "ZQ Power Down.",
  }],
 ["RESERVED_7_3",
  {
	pos: 3,
	width: 5,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["PGWAIT",
  {
	pos: 8,
	width: 3,
	type: "rw",
	default: 5,
	help: "Programmable Wait.",
  }],
 ["ZCALT",
  {
	pos: 11,
	width: 3,
	type: "rw",
	default: 1,
	help: "Impedance Calibration Type.",
  }],
 ["AVGMAX",
  {
	pos: 14,
	width: 2,
	type: "rw",
	default: 2,
	help: "Maximum Averaging Round.",
  }],
 ["AVGEN",
  {
	pos: 16,
	width: 1,
	type: "rw",
	default: 1,
	help: "Averaging Algorithm Enable.",
  }],
 ["IODLMT",
  {
	pos: 17,
	width: 8,
	type: "rw",
	default: 2,
	help: "IO VT Drift Limit.",
  }],
 ["RESERVED_26_25",
  {
	pos: 25,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["FORCE_ZCAL_VT_UPDATE",
  {
	pos: 27,
	width: 1,
	type: "rw",
	default: 0,
	help: "Force Impedance Calibration VT Update.",
  }],
 ["RESERVED_31_28",
  {
	pos: 28,
	width: 4,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["dtpr0", {
  help: "DRAM Timing Parameters Register 0",
  fields: new Map([
 ["TRTP",
  {
	pos: 0,
	width: 4,
	type: "rw",
	default: 8,
	help: "Internal read to precharge command delay.",
  }],
 ["RESERVED_7_4",
  {
	pos: 4,
	width: 4,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TRP",
  {
	pos: 8,
	width: 7,
	type: "rw",
	default: 14,
	help: "Precharge command period.",
  }],
 ["RESERVED_15",
  {
	pos: 15,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TRAS",
  {
	pos: 16,
	width: 7,
	type: "rw",
	default: 36,
	help: "Activate to precharge command delay.",
  }],
 ["RESERVED_23",
  {
	pos: 23,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TRRD",
  {
	pos: 24,
	width: 6,
	type: "rw",
	default: 7,
	help: "Activate to activate command delay (different banks).",
  }],
 ["RESERVED_31_30",
  {
	pos: 30,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["dtpr1", {
  help: "DRAM Timing Parameters Register 1",
  fields: new Map([
 ["TMRD",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 6,
	help: "Load mode cycle time.",
  }],
 ["RESERVED_7_5",
  {
	pos: 5,
	width: 3,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TMOD",
  {
	pos: 8,
	width: 3,
	type: "rw",
	default: 4,
	help: "Load mode update delay.",
  }],
 ["RESERVED_15_11",
  {
	pos: 11,
	width: 5,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TFAW",
  {
	pos: 16,
	width: 8,
	type: "rw",
	default: 38,
	help: "4-bank activate period.",
  }],
 ["TWLMRD",
  {
	pos: 24,
	width: 6,
	type: "rw",
	default: 40,
	help: "Minimum delay from when write leveling mode is programmed to the first DQS/DQS# rising edge..",
  }],
 ["RESERVED_31_30",
  {
	pos: 30,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["dtpr2", {
  help: "DRAM Timing Parameters Register 2",
  fields: new Map([
 ["TXS",
  {
	pos: 0,
	width: 10,
	type: "rw",
	default: 512,
	help: "Self refresh exit delay.",
  }],
 ["RESERVED_15_10",
  {
	pos: 10,
	width: 6,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TCKE",
  {
	pos: 16,
	width: 4,
	type: "rw",
	default: 6,
	help: "CKE minimum pulse width.",
  }],
 ["RESERVED_23_20",
  {
	pos: 20,
	width: 4,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TRTODT",
  {
	pos: 24,
	width: 1,
	type: "rw",
	default: 0,
	help: "Read to ODT delay.",
  }],
 ["RESERVED_27_25",
  {
	pos: 25,
	width: 3,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TRTW",
  {
	pos: 28,
	width: 1,
	type: "rw",
	default: 0,
	help: "Read to Write command delay.",
  }],
 ["RESERVED_31_29",
  {
	pos: 29,
	width: 3,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["dtpr3", {
  help: "DRAM Timing Parameters Register 3",
  fields: new Map([
 ["TDQSCK",
  {
	pos: 0,
	width: 3,
	type: "rw",
	default: 1,
	help: "DQS output access time from CK/CK#.",
  }],
 ["RESERVED_7_3",
  {
	pos: 3,
	width: 5,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TDQSCKMAX",
  {
	pos: 8,
	width: 3,
	type: "rw",
	default: 1,
	help: "Maximum DQS output access time from CK/CK#.",
  }],
 ["RESERVED_15_11",
  {
	pos: 11,
	width: 5,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TDLLK",
  {
	pos: 16,
	width: 10,
	type: "rw",
	default: 384,
	help: "DLL locking time.",
  }],
 ["TCCD",
  {
	pos: 26,
	width: 3,
	type: "rw",
	default: 0,
	help: "Read to read and write to write command delay.",
  }],
 ["TOFDX",
  {
	pos: 29,
	width: 3,
	type: "rw",
	default: 0,
	help: "ODT turn-off delay extension.",
  }],
  ])} ],
 ["dtpr4", {
  help: "DRAM Timing Parameters Register 4",
  fields: new Map([
 ["TXP",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 26,
	help: "Power down exit delay.",
  }],
 ["RESERVED_7_5",
  {
	pos: 5,
	width: 3,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TWLO",
  {
	pos: 8,
	width: 4,
	type: "rw",
	default: 8,
	help: "Write leveling output delay.",
  }],
 ["RESERVED_15_12",
  {
	pos: 12,
	width: 4,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TRFC",
  {
	pos: 16,
	width: 10,
	type: "rw",
	default: 374,
	help: "Refresh-to-Refresh.",
  }],
 ["RESERVED_27_26",
  {
	pos: 26,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TAOND_TAOFD",
  {
	pos: 28,
	width: 2,
	type: "rw",
	default: 0,
	help: "ODT turn-on/turn-off delays.",
  }],
 ["RESERVED_31_30",
  {
	pos: 30,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["dtpr5", {
  help: "DRAM Timing Parameters Register 5",
  fields: new Map([
 ["TWTR",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 8,
	help: "Internal write to read command delay.",
  }],
 ["RESERVED_7_5",
  {
	pos: 5,
	width: 3,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TRCD",
  {
	pos: 8,
	width: 7,
	type: "rw",
	default: 14,
	help: "Activate to read or write delay.",
  }],
 ["RESERVED_15",
  {
	pos: 15,
	width: 1,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TRC",
  {
	pos: 16,
	width: 8,
	type: "rw",
	default: 50,
	help: "Activate to activate command delay (same bank).",
  }],
 ["RESERVED_31_24",
  {
	pos: 24,
	width: 8,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["ptr0", {
  help: "PHY Timing Register 0",
  fields: new Map([
 ["TPHYRST",
  {
	pos: 0,
	width: 6,
	type: "rw",
	default: 16,
	help: "PHY Reset Time.",
  }],
 ["TPLLGS",
  {
	pos: 6,
	width: 15,
	type: "rw",
	default: 2134,
	help: "PLL Gear Shift Time.",
  }],
 ["TPLLPD",
  {
	pos: 21,
	width: 11,
	type: "rw",
	default: 534,
	help: "PLL Power-Down Time.",
  }],
  ])} ],
 ["ptr1", {
  help: "PHY Timing Register 1",
  fields: new Map([
 ["TPLLRST",
  {
	pos: 0,
	width: 13,
	type: "rw",
	default: 4800,
	help: "PLL Reset Time.",
  }],
 ["RESERVED_14_13",
  {
	pos: 13,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
 ["TPLLLOCK",
  {
	pos: 15,
	width: 17,
	type: "rw",
	default: 53334,
	help: "PLL Lock Time.",
  }],
  ])} ],
 ["ptr2", {
  help: "PHY Timing Register 2",
  fields: new Map([
 ["TCALON",
  {
	pos: 0,
	width: 5,
	type: "rw",
	default: 15,
	help: "Calibration On Time.",
  }],
 ["TCALS",
  {
	pos: 5,
	width: 5,
	type: "rw",
	default: 15,
	help: "Calibration Setup Time.",
  }],
 ["TCALH",
  {
	pos: 10,
	width: 5,
	type: "rw",
	default: 15,
	help: "Calibration Hold Time.",
  }],
 ["TWLDLYS",
  {
	pos: 15,
	width: 5,
	type: "rw",
	default: 16,
	help: "Write Leveling Delay Settling Time.",
  }],
 ["RESERVED_31_20",
  {
	pos: 20,
	width: 12,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["ptr3", {
  help: "PHY Timing Register 3",
  fields: new Map([
 ["TDINIT0",
  {
	pos: 0,
	width: 20,
	type: "rw",
	default: 533334,
	help: "DRAM Initialization Time 0.",
  }],
 ["TDINIT1",
  {
	pos: 20,
	width: 10,
	type: "rw",
	default: 384,
	help: "DRAM Initialization Time 1.",
  }],
 ["RESERVED_31_30",
  {
	pos: 30,
	width: 2,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
 ["ptr4", {
  help: "PHY Timing Register 4",
  fields: new Map([
 ["TDINIT2",
  {
	pos: 0,
	width: 18,
	type: "rw",
	default: 213334,
	help: "DRAM Initialization Time 2.",
  }],
 ["TDINIT3",
  {
	pos: 18,
	width: 11,
	type: "rw",
	default: 800,
	help: "DRAM Initialization Time 3.",
  }],
 ["RESERVED_31_29",
  {
	pos: 29,
	width: 3,
	type: "ro",
	default: 0,
	help: "Reserved for future use.",
  }],
  ])} ],
]);
